{"meta":{"title":"CodingDoge","subtitle":"关于开发、设计，关于生活。","description":"Keep it simple, stuip.","author":"CodingDoge","url":"http://codingdoge.cn"},"pages":[{"title":"","date":"2017-12-07T23:57:56.000Z","updated":"2017-12-07T23:03:58.000Z","comments":true,"path":"404.html","permalink":"http://codingdoge.cn/404.html","excerpt":"","text":"CodingDoge's blog | 404"},{"title":"","date":"2017-12-07T23:03:58.000Z","updated":"2017-12-07T23:03:58.000Z","comments":true,"path":"baidu_verify_pl2cC4IAHr.html","permalink":"http://codingdoge.cn/baidu_verify_pl2cC4IAHr.html","excerpt":"","text":"pl2cC4IAHr"},{"title":"About","date":"2017-07-20T04:10:23.000Z","updated":"2018-01-14T17:34:54.960Z","comments":true,"path":"about/index.html","permalink":"http://codingdoge.cn/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-12-20T17:58:19.000Z","updated":"2017-12-20T17:58:19.000Z","comments":false,"path":"categories/index.html","permalink":"http://codingdoge.cn/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-12-07T23:03:58.000Z","updated":"2017-12-07T23:03:58.000Z","comments":true,"path":"search/index.html","permalink":"http://codingdoge.cn/search/index.html","excerpt":"","text":"layout: search title: search"},{"title":"","date":"2018-01-14T17:27:15.013Z","updated":"2017-12-20T17:56:35.000Z","comments":false,"path":"tags/index.html","permalink":"http://codingdoge.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Just a test","slug":"test","date":"2018-01-14T18:00:21.152Z","updated":"2018-01-14T18:00:21.152Z","comments":true,"path":"2018/01/15/test/","link":"","permalink":"http://codingdoge.cn/2018/01/15/test/","excerpt":"","text":"aaa a dfadf","categories":[],"tags":[]},{"title":"Advanced Swift 笔记 —— 內建集合類型","slug":"title: Advanced Swift 笔记 —— 內建集合類型","date":"2017-08-30T07:47:00.000Z","updated":"2018-01-13T12:22:39.908Z","comments":true,"path":"2017/08/30/title: Advanced Swift 笔记 —— 內建集合類型/","link":"","permalink":"http://codingdoge.cn/2017/08/30/title: Advanced Swift 笔记 —— 內建集合類型/","excerpt":"","text":"數組(Array)盡量不要使用下標索引，如果下標越界會直接導致crash（在並發情況下尤其需要考慮）。 迭代全部 1for x in array 迭代除了第一個元素以外的其餘部分 1for x in array.dropFirst() 迭代除了最後5個元素以外的數組 1for x in array.dropLast(5) 列舉數組中的元素和對應下標 1for (index, value) in array.enumerated() 尋找一個指定元素的位置 123_ = array.index &#123; someMatchingLogic($0)&#125; 對數組所有元素變形 123_ = array.map &#123; someTransformation($0)&#125; 篩選符合某個標準的元素 123_ = array.filter &#123; someCriteria($0)&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Reading Notes","slug":"Reading-Notes","permalink":"http://codingdoge.cn/tags/Reading-Notes/"}]},{"title":"Brew Instruction","slug":"title: Brew Instruction","date":"2017-08-30T06:26:00.000Z","updated":"2018-01-13T12:36:00.696Z","comments":true,"path":"2017/08/30/title: Brew Instruction/","link":"","permalink":"http://codingdoge.cn/2017/08/30/title: Brew Instruction/","excerpt":"","text":"Brew brew help 查看有什麼可用的指令 brew search [someSuit] 查詢有無someSuit brew install [someSuit] 安裝someSuit brew info [someSuit] 查看someSuit的訊息 brew uninstall [someSuit] 移除someSuit brew list 列出已安裝套件 brew outdated 查詢那些套件已過期 brew cleanup -n 刪除舊的套件版本(-n 是顯示刪除的過程，可以了解有哪些套件被刪除了) brew upgrade [someSuit] 更新someSuit brew update &amp;&amp; brew upgrade &amp;&amp; brew doctor 更新Homebrew上面所有套件 brew dips [someSuit] 列出安裝someSuit需要的依賴套件 brew —prefix 查詢brew安裝的路徑 參考:chiehwen/Homebrew 指令詳解.mdHomebrew 指令","categories":[{"name":"Shell","slug":"Shell","permalink":"http://codingdoge.cn/categories/Shell/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://codingdoge.cn/tags/Tool/"}]},{"title":"Advanced Swift 笔记 —— Tips","slug":"title: Advanced Swift 笔记 —— Tips","date":"2017-08-20T09:35:00.000Z","updated":"2018-01-13T12:23:01.178Z","comments":true,"path":"2017/08/20/title: Advanced Swift 笔记 —— Tips/","link":"","permalink":"http://codingdoge.cn/2017/08/20/title: Advanced Swift 笔记 —— Tips/","excerpt":"","text":"Curried Function 柯里化函數一个函数不是接受多个参数，而是只接受部分参数，然后返回一个接受其余参数的函数。 Statically Dispatched 靜態派發定義在類或者協議中的函數就是方法(Method)，他們有一個隱式的self。不是方法的函數叫做自由函數(Free Function)。自由函数和那些在结构体上调用的方法是静态派发 (statically dispatched)的。对于这些函数的调用，在编译的时候就已经确定了。对于静态派发的调用，编译器可能能够内联 (inline)这些函数，也就是说，完全不去做函数调用，而是将这部分代码替换为需要执行的函数。静态派发还能够帮助编译器丢弃或者简化那些在编译时就能确定不会被实际执行的代码。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Reading Notes","slug":"Reading-Notes","permalink":"http://codingdoge.cn/tags/Reading-Notes/"}]},{"title":"剑指Offer —— 二叉搜索树的第k个结点","slug":"title: 剑指Offer —— 二叉搜索树的第k个结点","date":"2017-08-04T01:56:00.000Z","updated":"2018-01-14T16:29:06.979Z","comments":true,"path":"2017/08/04/title: 剑指Offer —— 二叉搜索树的第k个结点/","link":"","permalink":"http://codingdoge.cn/2017/08/04/title: 剑指Offer —— 二叉搜索树的第k个结点/","excerpt":"","text":"题目来源:牛客网 题目描述给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \\ 3 7 /\\ /\\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 解题思路 递归 迭代way1中序遍历，找到第k个结点。完全性的模拟左根右，注意返回结果的处理。 TreeNode* KthNode(TreeNode* pRoot, int k) { if (pRoot) { TreeNode *node = KthNode(pRoot-&gt;left, k); if (node) return node; index++; if (index == k) return pRoot; node = KthNode(pRoot-&gt;right, k); if (node) return node; } return NULL; }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://codingdoge.cn/tags/剑指Offer/"}]},{"title":"错误处理","slug":"title: 错误处理","date":"2017-08-03T02:47:00.000Z","updated":"2018-01-13T12:26:37.175Z","comments":true,"path":"2017/08/03/title: 错误处理/","link":"","permalink":"http://codingdoge.cn/2017/08/03/title: 错误处理/","excerpt":"","text":"错误处理（Error handling）是响应错误以及从错误中恢复的过程。Swift 提供了在运行时对可恢复错误的抛出、捕获、传递和操作的一等公民支持。 Swift 中有4种处理错误的方式 把函数抛出的错误传递给调用此函数的代码 用do-catch语句处理错误 将错误作为可选类型处理 或者断言此错误根本不会发生 Swift 中的错误处理并不涉及解除调用栈，这是一个计算代价高昂的过程。就此而言，throw语句的性能特性是可以和return语句相媲美的。 一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。 参考: The Swift Programming Language 中文版SWIFT 的必备 TIP","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://codingdoge.cn/tags/Swift/"}]},{"title":"Dispatch 在swift中的使用","slug":"title: Dispatch 在swift中的使用","date":"2017-08-03T01:49:00.000Z","updated":"2018-01-13T12:28:30.884Z","comments":true,"path":"2017/08/03/title: Dispatch 在swift中的使用/","link":"","permalink":"http://codingdoge.cn/2017/08/03/title: Dispatch 在swift中的使用/","excerpt":"","text":"创建队列当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。 1234567891011121314151617181920212223242526272829func downloadPhotosWithCompletion(completion: BatchPhotoDownloadingCompletionClosure?) &#123; dispatch_async(GlobalUserInitiatedQueue) &#123; // 因为dispatch_group_wait会租塞当前进程，所以要使用dispatch_async将整个方法要放到后台队列才能够保证主线程不被阻塞 var storedError: NSError! var downloadGroup = dispatch_group_create() // 创建一个dispatch group for address in [OverlyAttachedGirlfriendURLString, SuccessKidURLString, LotsOfFacesURLString] &#123; let url = NSURL(string: address) dispatch_group_enter(downloadGroup) // dispatch_group_enter是通知dispatch group任务开始了，dispatch_group_enter和dispatch_group_leave是成对调用，不然程序就崩溃了。 let photo = DownloadPhoto(url: url!) &#123; image, error in if let error = error &#123; storedError = error &#125; dispatch_group_leave(downloadGroup) // 保持和dispatch_group_enter配对。通知任务已经完成 &#125; PhotoManager.sharedManager.addPhoto(photo) &#125; dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER) // dispatch_group_wait等待所有任务都完成直到超时。如果任务完成前就超时了，函数会返回一个非零值，可以通过返回值判断是否超时。也可以用DISPATCH_TIME_FOREVER表示一直等。 dispatch_async(GlobalMainQueue) &#123; // 这里可以保证所有图片任务都完成，然后在main queue里加入完成后要处理的闭包，会在main queue里执行。 if let completion = completion &#123; // 执行闭包内容 completion(error: storedError) &#125; &#125; &#125;&#125; Serial Queues12345678910111213141516171819private let serialQueue = DispatchQueue(label: “serialQueue”)private var dictionary: [String: Any] = [:]public func set(_ value: Any, forKey key: String) &#123; serialQueue.sync &#123; dictionary[key] = value &#125;&#125;public func object(forKey key: String) -&gt; Any? &#123; var result: Any? serialQueue.sync &#123; result = storage[key] &#125; // returns after serialQueue is finished operation // beacuse serialQueue is run synchronously return result&#125; Concurrent Queues1234567891011121314151617181920private let concurrentQueue = DispatchQueue(label: &quot;concurrentQueue&quot;, attributes: .concurrent)private var dictionary: [String: Any] = [:] public func set(_ value: Any?, forKey key: String) &#123; concurrentQueue.async &#123; self.storage[key] = value &#125;&#125;public func object(forKey key: String) -&gt; Any? &#123; var result: Any? concurrentQueue.sync &#123; result = storage[key] &#125; // returns after concurrentQueue is finished operation // beacuse concurrentQueue is run synchronously return result&#125; Concurrent Queue with Barrier1234567891011121314151617181920212223private let concurrentQueue = DispatchQueue(label: &quot;concurrentQueue&quot;, attributes: .concurrent)private var dictionary: [String: Any] = [:] public func set(_ value: Any?, forKey key: String) &#123; // .barrier flag ensures that within the queue all reading is done // before the below writing is performed and // pending readings start after below writing is performed concurrentQueue.async(flags: .barrier) &#123; self.storage[key] = value &#125;&#125;public func object(forKey key: String) -&gt; Any? &#123; var result: Any? concurrentQueue.sync &#123; result = storage[key] &#125; // returns after concurrentQueue is finished operation // beacuse concurrentQueue is run synchronously return result&#125; 延时1234567891011121314151617181920212223242526272829303132333435typealias Task = (_ cancel: Bool) -&gt; Void func delay(time: TimeInterval, task: @escaping ()-&gt;()) -&gt; Task? &#123; func dispatch_later(block: @escaping ()-&gt;()) &#123; DispatchQueue.main.asyncAfter(deadline: DispatchTime.now()+time, execute: block) &#125; var closure: (()-&gt;())? = task var result: Task? let delayedClosure: Task = &#123; cancel in if let internalClosure = closure &#123; if cancel == false &#123; DispatchQueue.main.async &#123; internalClosure() &#125; &#125; &#125; closure = nil result = nil &#125; result = delayedClosure dispatch_later &#123; if let delayedClosure = result &#123; delayedClosure(false) &#125; &#125; return result &#125; func cancel(task: Task?) &#123; task?(true) &#125; 网络场景异步开启下载、取消下载，开始下载前保证没有遗留下载任务12345678910111213fileprivate let barrierQueue = DispatchQueue(label: \"com.meitu.meipu.videoCache.barrierQueue\")func downloader(url: URL) &#123; barrierQueue.sync &#123; [weak self] in // add downloader task &#125;&#125;func cancel() &#123; barrierQueue.async(group: nil, qos: .default, flags: .barrier) &#123; // cacle task &#125;&#125; 参考:GCD 在 Swift 3 中的玩儿法GCD 使用指南Swift 3 中的 GCD 与 Dispatch QueueSwift 3學習指南：重新認識GCD應用GCD精讲（Swift 3）","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://codingdoge.cn/tags/Swift/"}]},{"title":"Dispatch","slug":"title: Dispatch","date":"2017-08-02T12:01:00.000Z","updated":"2018-01-13T04:59:21.648Z","comments":true,"path":"2017/08/02/title: Dispatch/","link":"","permalink":"http://codingdoge.cn/2017/08/02/title: Dispatch/","excerpt":"","text":"Execute code concurrently on multicore hardware by submitting work to dispatch queues managed by the system. 在多核硬件上，通过提交任务到由这个系统管理的派遣队列上，并发的执行代码。 一种把保证回调会在主线程执行的方法: 12345678#ifndef dispatch_main_async_safe#define dispatch_main_async_safe(block)\\ if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\\ block();\\ &#125; else &#123;\\ dispatch_async(dispatch_get_main_queue(), block);\\ &#125;#endif 12345678910dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();for(id obj in array) dispatch_group_async(group, queue, ^&#123; [self doSomethingIntensiveWith:obj]; &#125;);dispatch_group_wait(group, DISPATCH_TIME_FOREVER);dispatch_release(group); [self doSomethingWith:array]; 12345678910dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_group_t group = dispatch_group_create();for(id obj in array) dispatch_group_async(group, queue, ^&#123; [self doSomethingIntensiveWith:obj]; &#125;);dispatch_group_notify(group, queue, ^&#123; [self doSomethingWith:array];&#125;);dispatch_release(group); dispatch_barrier_sync和dispatch_barrier_async common different 等待在它前面插入队列的任务先执行完 dispatch_barrier_sync将自己的任务插入到队列的时候，需要等待自己的任务结束之后才会继续插入被写在它后面的任务，然后执行它们 等待他们自己的任务执行完再执行后面的任务 dispatch_barrier_async将自己的任务插入到队列之后，不会等待自己的任务结束，它会继续把后面的任务插入到队列，然后等待自己的任务结束后才执行后面任务 参考:GCD入门（一）: 基本概念和Dispatch Queue深入理解GCD底层并发 APIGCD 中 dispatch_once 的性能与实现读 Concurrency Programming Guide 笔记（一）iOS并发编程","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://codingdoge.cn/tags/多线程/"}]},{"title":"剑指Offer —— 最小的k个数","slug":"title: 剑指Offer —— 最小的k个数","date":"2017-08-01T02:20:00.000Z","updated":"2018-01-14T16:32:50.507Z","comments":true,"path":"2017/08/01/title: 剑指Offer —— 最小的k个数/","link":"","permalink":"http://codingdoge.cn/2017/08/01/title: 剑指Offer —— 最小的k个数/","excerpt":"","text":"题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。(很典型的题目了) 解题思路 插入或者冒泡排序，优化点在记录已排好的个数(O(n*k)) 最小堆(O(nlogk)) 快排思想(O(n)) way1不上代码了。 way2上个建堆的算法，通用、解耦、易测试😂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void HeapAdjust(int H[],int s, int length) &#123; int tmp = H[s]; int child = 2*s+1; //左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置) while (child &lt; length) &#123; if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) &#123; // 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点) ++child ; &#125; if(H[s]&lt;H[child]) &#123; // 如果较大的子结点大于父结点 H[s] = H[child]; // 那么把较大的子结点往上移动，替换它的父结点 s = child; // 重新设置s ,即待调整的下一个结点的位置 child = 2*s+1; &#125; else &#123; // 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出 break; &#125; H[s] = tmp; // 当前待调整的结点放到比其大的孩子结点位置上 &#125; print(H,length); &#125; /** * 初始堆进行调整 * 将H[0..length-1]建成堆 * 调整完之后第一个元素是序列的最小的元素 */ void BuildingHeap(int H[], int length) &#123; //最后一个有孩子的节点的位置 i= (length -1) / 2 for (int i = (length -1) / 2 ; i &gt;= 0; i--) &#123; cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; endl; HeapAdjust(H,i,length); &#125;&#125; /** * 堆排序算法 */ void HeapSort(int H[],int length) &#123; //初始堆 BuildingHeap(H, length); //从最后一个元素开始对序列进行调整 for (int i = length - 1; i &gt; 0; --i) &#123; //交换堆顶元素H[0]和堆中最后一个元素 int temp = H[i]; H[i] = H[0]; H[0] = temp; //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整 HeapAdjust(H,0,i); &#125; &#125; way31234567891011121314151617181920212223242526272829303132333435363738394041int Partition(vector&lt;int&gt; &amp;input, int begin, int end)&#123;trueint first = begin;trueint last = end;trueint pivot = input[first];truewhile (first &lt; last)true&#123;truetruewhile (first &lt; last &amp;&amp; input[last] &gt;= pivot) last--;truetrueinput[first] = input[last];truetruewhile (first &lt; last &amp;&amp; input[first] &lt;= pivot) first++;truetrueinput[last] = input[first];true&#125;trueinput[first] = pivot;truereturn first;&#125;vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; &amp;input, int k)&#123;trueint len=input.size();truevector&lt;int&gt; res;trueif(len==0||k&gt;len||k&lt;=0) return res;trueif(len==k) return input;trueint start=0;trueint end=len-1;trueint index=Partition(input,start,end);truewhile(index!=(k-1))true&#123;truetrueif(index&gt;k-1)truetrue&#123;truetruetrueend=index-1;truetruetrueindex=Partition(input,start,end);truetrue&#125;truetrueelsetruetrue&#123;truetruetruestart=index+1;truetruetrueindex=Partition(input,start,end);truetrue&#125;true&#125;truefor (int i = 0; i &lt; k; i++)truetrueres.push_back(input[i]);truereturn res;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://codingdoge.cn/tags/剑指Offer/"}]},{"title":"并发(concurrency)和并行(parallelism)","slug":"title: 并发(concurrency)和并行(parallelism)","date":"2017-07-27T04:29:00.000Z","updated":"2018-01-13T14:00:58.116Z","comments":true,"path":"2017/07/27/title: 并发(concurrency)和并行(parallelism)/","link":"","permalink":"http://codingdoge.cn/2017/07/27/title: 并发(concurrency)和并行(parallelism)/","excerpt":"","text":"“并发”指的是程序的结构，“并行”指的是程序运行时的状态 并行（parallelism）这个概念很好理解。所谓并行，就是同时执行的意思，无需过度解读。判断程序是否处于并行的状态，就看同一时刻是否有超过一个“工作单位”在运行就好了。所以，单线程永远无法达到并行状态。 要达到并行状态，最简单的就是利用多线程和多进程。 并发（concurrency）要理解“并发”这个概念，必须得清楚，并发指的是程序的“结构”。当我们说这个程序是并发的，实际上，这句话应当表述成“这个程序采用了支持并发的设计”。好，既然并发指的是人为设计的结构，那么怎样的程序结构才叫做支持并发的设计？ 正确的并发设计的标准是：使多个操作可以在重叠的时间段内进行(two tasks can start, run, and complete in overlapping time periods)。 这句话的重点有两个。我们先看“（操作）在重叠的时间段内进行”这个概念。它是否就是我们前面说到的并行呢？是，也不是。并行，当然是在重叠的时间段内执行，但是另外一种执行模式，也属于在重叠时间段内进行。这就是协程。 使用协程时，程序的执行看起来往往是这个样子： task1, task2 是两段不同的代码，比如两个函数，其中黑色块代表某段代码正在执行。注意，这里从始至终，在任何一个时间点上都只有一段代码在执行，但是，由于 task1 和 task2 在重叠的时间段内执行，所以这是一个支持并发的设计。与并行不同，单核单线程能支持并发。 Different concurrent designs enable different ways to parallelize","categories":[{"name":"OS","slug":"OS","permalink":"http://codingdoge.cn/categories/OS/"}],"tags":[]},{"title":"iOS 保持界面流畅的技巧","slug":"title: iOS 保持界面流畅的技巧","date":"2017-07-25T06:21:00.000Z","updated":"2018-01-14T16:35:13.663Z","comments":true,"path":"2017/07/25/title: iOS 保持界面流畅的技巧/","link":"","permalink":"http://codingdoge.cn/2017/07/25/title: iOS 保持界面流畅的技巧/","excerpt":"","text":"iOS 保持界面流畅的技巧 CPU 资源消耗原因和解决方案对象创建对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。 尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 对象调整对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。 当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 对象销毁对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。 12345NSArray *tmp = self.array;self.array = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;); 布局计算视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。 不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。 AutolayoutAutolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：http://pilky.me/36/。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。 文本计算如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。 如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。 文本渲染屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。 图片的解码当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 图像的绘制图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）： 1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; GPU 资源消耗原因和解决方案相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。 纹理的渲染所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。 当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。 视图的混合 (Composing)当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。 图形的生成CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。 参考:iOS 保持界面流畅的技巧","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"UI","slug":"UI","permalink":"http://codingdoge.cn/tags/UI/"}]},{"title":"剑指Offer —— 滑动窗口的最大值","slug":"title: 剑指Offer —— 滑动窗口的最大值","date":"2017-07-25T02:43:00.000Z","updated":"2018-01-14T16:38:57.866Z","comments":true,"path":"2017/07/25/title: 剑指Offer —— 滑动窗口的最大值/","link":"","permalink":"http://codingdoge.cn/2017/07/25/title: 剑指Offer —— 滑动窗口的最大值/","excerpt":"","text":"题目来源:滑动窗口的最大值 题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 解题思路用一个双端队列维护当前滑动窗口的状态，队首是当前窗口最大值的下标，当窗口滑动进入一个新值k时，k从队尾依次向前比较，比k小的全部出队，保障了k的权重应有的位置 123456789101112131415161718192021vector&lt;int&gt; maxInWindows(const vector&lt;int&gt; &amp;num, unsigned int size) &#123;truevector&lt;int&gt; ans;truedeque&lt;int&gt; q;trueif (num.size() &lt; size || size == 0) true return ans;truefor (int i = 0; i &lt; size; i++) &#123;true while(!q.empty() &amp;&amp; num[i] &gt; num[q.back()])true q.pop_back();true q.push_back(i);true&#125;truefor (int i = size; i &lt; num.size(); i++) &#123;true ans.push_back(num[q.front()]);true while (!q.empty() &amp;&amp; num[i] &gt;= num[q.back()])true q.pop_back();true while (!q.empty() &amp;&amp; q.front() &lt;= i-size)true q.pop_front();true q.push_back(i);true&#125;trueans.push_back(num[q.front()]);truereturn ans;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://codingdoge.cn/tags/剑指Offer/"}]},{"title":"Remove Duplicates from Sorted Array","slug":"title: Remove Duplicates from Sorted Array  ","date":"2017-07-23T15:56:00.000Z","updated":"2018-01-14T16:41:30.178Z","comments":true,"path":"2017/07/23/title: Remove Duplicates from Sorted Array  /","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: Remove Duplicates from Sorted Array  /","excerpt":"","text":"题目来源LeetCode: LeetCode OJ 题目描述Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this in place with constant memory.For example,Given input array nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length. 题目解释给出一个sorted array(意思是指已经排好序了?)，处理后数组里每一个元素只能出现一次，返回处理后的数组长度。不能使用额外的数组空间，只能用已经给出的确定的内存空间。 分析因为不太懂sorted array具体指的什么，第一次做的时候以为数组是随机的，相同元素出现的位置是随机的，然后题目也没给出limit time，随手就写了一个O(n^3) 12345678910for(int i = 0; i &lt; num; i++)&#123; truefor(int j = i+1; j &lt; num; j++)&#123; truetrueif(array[i] == array[j])&#123; for(int k = j; k &lt; num-1; k++) array[k] = array[k+1]; num--; j--; &#125; &#125; &#125; 自然是T了。然后就把sorted array当做已经排好序的数组，那就容易多了，算法也都是O(1)，一看代码就明白，水题，直接上代码。 way11234567if (nums.empty()) return 0; int index = 0; for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[index] != nums[i]) nums[++index] = nums[i]; &#125; return index + 1; way2 STL1return distance(nums.begin(), unique(nums.begin(), nums.end())); std::distancetemplatetypename iterator_traits::difference_type distance (InputIterator first, InputIterator last);Return distance between iteratorsCalculates the number of elements between first and last.c++ reference std::uniqueequality (1)template ForwardIterator unique (ForwardIterator first, ForwardIterator last);predicate (2)template ForwardIterator unique (ForwardIterator first, ForwardIterator last, BinaryPredicate pred); Remove consecutive duplicates in rangeRemoves all but the first element from every consecutive group of equivalent elements in the range [first,last).c++ reference 相关题目RemoveDuplicatesfromSortedArrayII","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codingdoge.cn/tags/LeetCode/"}]},{"title":"常见排序算法总结","slug":"title: 常见排序算法总结  ","date":"2017-07-23T15:56:00.000Z","updated":"2018-01-14T16:45:17.006Z","comments":true,"path":"2017/07/23/title: 常见排序算法总结  /","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /","excerpt":"","text":"排序算法一般分为： 内部排序(In-place sort) 不占用额外内存或者占用常数内存，如：插入排序、选择排序、冒泡排序、堆排序、快速排序。 外部排序(Out-place sort) 因为排序数据大，可用内存一次不能容纳所有排序记录，排序过程中需要访问外存，如：归并排序、计数排序、基数排序、桶排序。 也分为： 稳定的排序(stable sort) 插入排序、冒泡排序、归并排序、计数排序、基数排序、桶排序。 不稳定的排序(unstable sort) 选择排序、快速排序、堆排序。 算法的稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。 不稳定算法的改进：只需要在每个输入元素加一个index，表示初始时的数组索引，当不稳定的算法排好序后，对于相同的元素对index排序即可。 插入排序 最优复杂度：当输入数组就是排好序的时候，复杂度为O(n)，而快速排序在这种情况下会产生O(n^2)的复杂度。最差复杂度：当输入数组为倒序时，复杂度为O(n^2)。 插入排序比较适合用于“少量元素的数组”。插入排序比较适合用于“少量元素的数组”。 1.直接插入排序（Straight Insertion Sort） 工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 直接插入排序示例： 如果排序时碰到相等的元素，比较后会把相等的元素放在后面，所以这两个相等的元素之间的前后顺序没有改变，排序是稳定的。 算法的实现： 123456789101112131415161718void InsertSort(int a[], int n)&#123; for(int i = 1; i &lt; n; i++) &#123; if(a[i] &lt; a[i-1]) //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 &#123; int j = i-1; int temp = a[i]; //存储待排序元素 a[i] = a[i-1]; //先后移一个元素 while(x &lt; a[j] &amp;&amp; j &gt;= 0) //查找在有序表中的插入位置，并注意边界判断 &#123; a[j+1] = a[j]; j--; //元素后移 &#125; a[j+1] = temp; //插入到正确位置 &#125; &#125;&#125; 如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。直接插入排序算法的优化算法有：二分插入排序，2-路插入排序。 2.希尔排序（Shell’s Sort） 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。它是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 基本原理是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。算法具体描述如下： 选择一个步长，其设计者Donald Shell最初建议步长选择为n/2并且对步长取半直到步长达到1； 以步长为间隔对序列进行排序； 重复步骤2直到步长为1。 希尔排序的示例： 希尔排序是不稳定的。 算法的实现： 1234567891011121314void ShellInsertSort(int a[], int n)&#123; for (int gap=n&gt;&gt;1; gap&gt;0; gap&gt;&gt;=1) // 确定步长，直到步长为1 &#123; for (int i=gap; i&lt;n; i++) // 以步长为间隔进行排序 &#123; int temp = a[i]; int j; for (j=i-gap; j&gt;=0&amp;&amp;a[j]&gt;temp; j-=gap) // 排序细节 a[j+gap] = a[j]; a[j+gap] = temp; &#125; &#125;&#125; 可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自两个算式[1]。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 选择排序 简单选择排序（Simple Selection Sort） 基本原理是在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。算法的具体描述如下： 第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换； 第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换； 以此类推….. 第i趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换， 直到整个序列按关键码有序。 简单选择排序的示例： 算法实现： 1234567891011void SelectSort(int a[], int n)&#123;trueint min = a[0];truefor (int i = 0; i &lt; n; i++)true&#123;truetruefor (int j = i; j &lt; n; j++) // 每次选出序列中最小的数truetruetrueif (a[j] &lt; min)truetruetruetruemin = a[j];truetruea[i] = min; // 将每次选好的数放在正确的位置true&#125;&#125; 选择排序是稳定的。 选择排序的交换操作介于0和(n-1)次之间。选择排序的比较操作为n(n-1)次之间。选择排序的赋值操作介于0和3(n-1)次之间。比较次数O(n^2 )，比较次数与关键字的初始状态无关，总的比较次数N=(n-1)+(n-2)+…+1=n(n-1)/2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。 简单排序的改进——二元选择排序简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下： 123456789101112131415161718void SelectSort(int r[],int n) &#123; int i ,j , min ,max, tmp; for (i=1 ;i &lt;= n/2;i++) &#123; // 做不超过n/2趟选择排序 min = i; max = i ; //分别记录最大和最小关键字记录位置 for (j= i+1; j&lt;= n-i; j++) &#123; if (r[j] &gt; r[max]) &#123; max = j ; continue ; &#125; if (r[j]&lt; r[min]) &#123; min = j ; &#125; &#125; //该交换操作还可分情况讨论以提高效率 tmp = r[i-1]; r[i-1] = r[min]; r[min] = tmp; tmp = r[n-i]; r[n-i] = r[max]; r[max] = tmp; &#125; &#125; 堆排序（Heap Sort） 堆排序是指利用堆这种数据结构所设计的一种排序算法。其基本原理如下：堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如： 大顶堆序列：（96, 83, 27, 38, 11, 09) 小顶堆序列：（12, 36, 24, 85, 47, 30, 53, 91） 初始时把n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。因此，实现堆排序需解决两个问题： 如何将n 个待排序的数建成堆； 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。 首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。调整小顶堆的方法： 设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。 将根结点与左、右子树中较小元素的进行交换。 若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 2. 若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 2. 继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。 称这个自根结点到叶子结点的调整过程为筛选。如图： 再讨论对n 个元素初始建堆的过程。建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。 n个结点的完全二叉树，则最后一个结点是第个结点的子树。 筛选从第个结点为根的子树开始，该子树成为堆。 之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。 如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49） 算法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 已知H[s…m]除了H[s] 外均满足堆的定义 * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选, * * @param H是待调整的堆数组 * @param s是待调整的数组元素的位置 * @param length是数组的长度 * */ void HeapAdjust(int H[],int s, int length) &#123; int tmp = H[s]; int child = 2*s+1; //左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置) while (child &lt; length) &#123; if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) // 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点) ++child; if(H[s]&lt;H[child]) &#123; // 如果较大的子结点大于父结点 H[s] = H[child]; // 那么把较大的子结点往上移动，替换它的父结点 s = child; // 重新设置s ,即待调整的下一个结点的位置 child = 2*s+1; &#125; else // 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出 break; H[s] = tmp; // 当前待调整的结点放到比其大的孩子结点位置上 &#125; &#125; /** * 初始堆进行调整 * 将H[0..length-1]建成堆 * 调整完之后第一个元素是序列的最小的元素 */ void BuildingHeap(int H[], int length) &#123; //最后一个有孩子的节点的位置 i= (length -1) / 2 for (int i = (length -1) / 2 ; i &gt;= 0; i--) HeapAdjust(H,i,length);&#125; /** * 堆排序算法 */ void HeapSort(int H[],int length) &#123; //初始堆 BuildingHeap(H, length); //从最后一个元素开始对序列进行调整 for (int i = length - 1; i &gt; 0; --i) &#123; //交换堆顶元素H[0]和堆中最后一个元素 int temp = H[i]; H[i] = H[0]; H[0] = temp; //每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整 HeapAdjust(H,0,i); &#125; &#125; 堆排序是不稳定的。 设树深度为k， 次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式： 而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn )。 交换排序冒泡排序（Bubble Sort） 冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。冒泡排序示例： 算法的实现： 1234567891011void bubbleSort(int a[], int n)&#123; for(int i =0 ; i&lt; n-1; ++i) for(int j = 0; j &lt; n-i-1; ++j) if(a[j] &gt; a[j+1]) &#123; int tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; &#125; &#125; 冒泡排序是稳定的。 冒泡算法的改进对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。改进后算法如下： 1234567891011121314151617void Bubble_1 ( int r[], int n)&#123; int i = n -1; //初始时,最后位置保持不变 while (i &gt; 0) &#123; int pos= 0; //每趟开始时,无记录交换 for (int j = 0; j &lt; i; j++) if (r[j] &gt; r[j+1]) &#123; pos = j; //记录交换的位置 int tmp = r[j]; r[j] = r[j+1]; r[j+1] = tmp; &#125; i = pos; //为下一趟排序作准备 &#125; &#125; 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。改进后的算法为： 12345678910111213141516171819202122232425void Bubble_2 (int r[], int n)&#123; int low = 0; int high = n-1; //设置变量的初始值 int tmp, j; while (low &lt; high) &#123; for (j = low; j &lt; high; ++j) //正向冒泡,找到最大者 if (r[j] &gt; r[j+1]) &#123; tmp = r[j]; r[j]=r[j+1]; r[j+1]=tmp; &#125; --high; //修改high值, 前移一位 for (j = high; j &gt; low; --j) //反向冒泡,找到最小者 if (r[j] &lt; r[j-1]) &#123; tmp = r[j]; r[j]=r[j-1]; r[j-1]=tmp; &#125; ++low; //修改low值,后移一位 &#125; &#125; 快速排序（Quick Sort） 快速排序又称划分交换排序（partition-exchange sort），使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。其算法描述为： 从数列中挑出一个元素，称为”基准”（pivot）。 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 快速排序的示例： 一趟排序的过程 排序的全过程 算法的实现（递归）： 1234567891011121314151617181920void quickSort_recursive(int a[], int low, int high)&#123; int first = low; int last = high; int key = a[first]; if(low &gt;= high) return ; while(first &lt; last) &#123; while((first &lt; last)&amp;&amp;(key &lt;= a[last])) last--; a[first] = a[last]; while((first &lt; last)&amp;&amp;(key &gt;= a[first])) first++; a[last] = a[first]; &#125; a[first] = key; quickSort_recursive(a, low, first-1); quickSort_recursive(a, first+1, high);&#125; 快速排序是不稳定的。快排迭代算法:维护一个栈，存放划分的起点终点 在平均状况下，排序n个项目要Ο(nlogn)次比较。在最坏状况下（正序或逆序）则需要Ο(n^2 )次比较，取决于其递归树的高度。事实上，快速排序通常明显比其他Ο(nlogn)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。快速排序是一个不稳定的排序方法。 归并排序（Merge Sort） 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 递归法 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素 重复步骤2，直到所有元素排序完毕 算法实现： 12345678910111213141516171819202122232425void merge_sort_recursive(int arr[], int reg[], int start, int end)&#123; if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(arr, reg, start1, end1); merge_sort_recursive(arr, reg, start2, end2); int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) reg[k++] = arr[start1++]; while (start2 &lt;= end2) reg[k++] = arr[start2++]; for (k = start; k &lt;= end; k++) arr[k] = reg[k];&#125;void merge_sort(int arr[], const int len)&#123;trueint reg[len];truemerge_sort_recursive(arr, reg, 0, len - 1);&#125; 两路归并的递归算法12345678910111213141516void MSort(ElemType *r, ElemType *rf,int s, int t) &#123; ElemType *rf2; if(s==t) r[s] = rf[s]; else &#123; int m=(s+t)/2; /*平分*p 表*/ MSort(r, rf2, s, m); /*递归地将p[s…m]归并为有序的p2[s…m]*/ MSort(r, rf2, m+1, t); /*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/ Merge(rf2, rf, s, m+1,t); /*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/ &#125; &#125; void MergeSort_recursive(ElemType *r, ElemType *rf, int n) &#123; /*对顺序表*p 作归并排序*/ MSort(r, rf,0, n-1); &#125; 迭代法 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤3直到某一指针到达序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾； 算法实现： 12345678910111213141516171819202122232425262728293031void merge_sort_iteration(int arr[], int len)&#123; int* a = arr; int* b = new int[len]; for (int seg = 1; seg &lt; len; seg += seg) &#123; for (int start = 0; start &lt; len; start += seg + seg) &#123; int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len); int k = low; int start1 = low, end1 = mid; int start2 = mid, end2 = high; while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; while (start1 &lt; end1) b[k++] = a[start1++]; while (start2 &lt; end2) b[k++] = a[start2++]; &#125; T* temp = a; a = b; b = temp; &#125; if (a != arr) &#123; for (int i = 0; i &lt; len; i++) b[i] = a[i]; b = a; &#125; delete[] b;&#125; 归并排序是稳定的。 总结各种排序的稳定性，时间复杂度和空间复杂度总结： 参考资料有：真实的归宿——八大排序算法xiazdong——九大排序算法再总结wikipedia","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[]},{"title":"Search in Rotated Sorted Array","slug":"title: Search in Rotated Sorted Array  ","date":"2017-07-23T15:56:00.000Z","updated":"2018-01-12T14:25:37.504Z","comments":true,"path":"2017/07/23/title: Search in Rotated Sorted Array  /","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: Search in Rotated Sorted Array  /","excerpt":"","text":"题目来源LeetCode: LeetCode OJ 题目描述: Suppose a sorted array is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array. 题目解释一个排好序的数组，不知道以哪个点为中心旋转了(部分有序)，你的任务是查找给定的数是否存在数组中。在的话返回下标，不在的话返回－1. 分析查找首先想到O(log(n))的二分查找，但是二分查找的前提是有序数组。题目里一个有序数组旋转后变成了部分有序。通过比较两端大小找到增序部分。 eg: 4 5 6 0 1 2 3first = 4, mid = 0, last = 3，通过比较first,mid,last找到增序部分。在这个例子中为1 2 3，然后判断target是否在这个增序子序列中，如果在则直接用二分查找，不在则在另一部分(例子中为4 5 6 0)中继续分解。 Codeint search(const vector&lt;int&gt;&amp; nums, int target) { int first = 0; int last = nums.size(); while(first != last) { const int mid = (first+last)&gt;&gt;1; // 使用位运算加速 if(nums[mid] == target) return mid; if(nums[first] &lt;= nums[mid]) // 找到增序子序列 if(nums[first]&lt;=target &amp;&amp; target&lt;nums[mid]) // 找到target在哪个部分 last = mid; else first = mid+1; else if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[last-1]) first = mid+1; else last = mid; } return -1; } 拓展当数组为无序时的二分查找 分析一种是先排序再二分，一种是结合快排思想，每次选择一个关键字，比他大的放右边，比他小的放左边，然后再比较他和需要查找的数的关系，再选择区间进行迭代。如果需要返回查找数的下标，则添加一个纪录下标的数组，这样排好序后也能知道当前数在原始数组中的位置。 初始数组3 1 2 5 4 7 0 6mid = key = 3 进行一次快排填坑得到数组0 1 2 3 4 7 5 6比较mid与target如果target&gt;mid则迭代mid后半部分如果target&lt;mid则迭代mid前半部分直到找到target Codeint BinarySearch(vector&lt;int&gt;&amp; nums, int target) { int num = nums.size(); int index[num]; // index数组纪录下标 以便能找到在数组的初始位置 for(int i = 0; i &lt; num; i++) // 初始化index数组 index[i] = i; int l, r, m, sl, sr, mIndex; l = 0, r = num-1; while(l&lt;=r) // 开始迭代 { mIndex = index[l], m = nums[l]; sl = l, sr = r; while(sl&lt;sr) // 快排思想，左右填坑，并用index记录位置 { while(sl&lt;sr &amp;&amp; m&lt;nums[sr]) sr--; nums[sl] = nums[sr]; index[sl] = index[sr]; while(sl&lt;sr &amp;&amp; m&gt;nums[sl]) sl++; nums[sr] = nums[sl]; index[sr] = index[sl]; } nums[sl] = m; index[sl] = mIndex; if(m == target) return mIndex; if(target &gt; m) // 判断target在哪个区间 l = sl+1; else r = sl-1; } return -1; } 相关题目Search in Rotated Sorted Array II 相关题目分析因为允许出现重复数字，但是数组还是部分有序的，所以跳过重复数字即可 Codeint search(const vector&lt;int&gt;&amp; nums, int target) { int first = 0; int last = nums.size(); while(first != last) { const int mid = (first+last)&gt;&gt;1; if(nums[mid] == target) return mid; if(nums[first] &lt; nums[mid]) if(nums[first]&lt;=target &amp;&amp; target&lt;nums[mid]) last = mid; else first = mid+1; else if(nums[first] &gt; nums[mid]) { if(nums[mid]&lt;target &amp;&amp; target&lt;=nums[last-1]) first = mid+1; else last = mid; } else // 特判相等时跳过 first++; } return -1; }","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://codingdoge.cn/tags/LeetCode/"}]},{"title":"CocoaPods 安装及一般使用","slug":"title: CocoaPods 安装及一般使用","date":"2017-07-23T15:47:00.000Z","updated":"2018-01-13T05:06:34.464Z","comments":true,"path":"2017/07/23/title: CocoaPods 安装及一般使用/","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: CocoaPods 安装及一般使用/","excerpt":"","text":"WHAT IS COCOAPODSCocoaPods is a dependency manager for Swift and Objective-C Cocoa projects.CocoaPods can help you scale your projects elegantly. INSTALLCocoaPods是基于ruby建立的，要确保你的电脑里装有Ruby，不过Mac都是自带Ruby的，你可以用rvm来管理你的ruby. RVM 实用指南 · Ruby China然后我们使用Rubygem来安装cocoapods.由于GFW的原因我们不能访问cocoapods.org，使用淘宝的Ruby镜像来代替： 删除自带的Ruby镜像$ gem sources --remove https://rubygems.org/ 添加淘宝的镜像$ gem sources -a https://gems.ruby-china.org/（如果这个镜像不能用，就用https://gems.ruby-china.org/） 可以用$ gem sources -l来检验。成功即显示以下结果： FF76DDA8-EC18-438C-B921-8603D4688C1D 安装CocoaPods$ sudo gem install cocoapods 配置CocoaPods$ pod setup 如果安装失败的话，根据报错去解决问题，比如gem没更新，ruby版本等。常见问题：While executing gem ... (Errno::EPERM)1Operation not permitted - /usr/bin/xcodeproj 安装Cocoapods， 更新gem出现的问题。 - SegmentFaultios - Cannot install cocoa pods after uninstalling, results in error - Stack Overflow Using CocoaPods 使用之前你要确保你所想用的库存在CocoaPods中：(拿AFNetworking举例)$ pod search AFNetworking第一次搜索会需要建立索引，比较慢一些。 搜索完成后会列举出结果和版本： 37122577-4CDC-48C9-9B25-4B943D983810 然后通过创建Podfile文件来添加依赖关系 先cd进你项目所在的目录(简介里面可以直接复制路径) 利用vim创建Podfile文件$ vim Podfile 然后输入：12345platform :ios, '10.0'target 'TargetName' dopod 'AFNetworking', '~&gt; 3.0'end 文字的意思是，当前AFNetworking支持的iOS最高版本是iOS 10.0，’TargetName’为你项目的名称，要下载的AFNetworking版本是3.0保存退出。 运行$ pod install完成后会出现提示使用’XXX.xcworkspace’文件来代替之前的’XXX.xcodeproj’文件打开项目。打开项目后会发现里面有了我们想要加进来的库，可以#import进来了。 增加新的库如果使用过程中我还想添加其他的库怎么办，只要在Podfile里面接着添加，然后终端再执行pod install就可以了。 更新CocoaPods中的库第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。 删除CocoaPods中的某些库当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。 升级CocoaPodssudo gem install cocoapods","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://codingdoge.cn/tags/Tool/"}]},{"title":"self与super的区别","slug":"title: self与super的区别 ","date":"2017-07-23T15:47:00.000Z","updated":"2018-01-14T16:47:12.060Z","comments":true,"path":"2017/07/23/title: self与super的区别 /","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: self与super的区别 /","excerpt":"","text":"原文CSDN evilotus有所整理 在ObjC中的类实现中经常看到这两个关键字”self”和”super”，以以前oop语言的经验，拿c++为例，self相当于this，super相当于调用父类的方法，这么看起来是很容易理解的。但是它们真正是如何调用的呢? 你知道吗? 以下面的代码为例： 12345678910111213141516171819202122232425262728@interface Person:NSObject&#123;trueNSString* name;&#125; (void) setName:(NSString) yourName;@end //Person @interface PersonMe:Person&#123;trueNSUInteger age;&#125; (void) setAge:(NSUInteger) age; (void) setName:(NSString*) yourName andAge:(NSUInteger) age;@end // PersonMe @implementation PersonMe(void) setName:(NSString*) yourName andAge:(NSUInteger) age&#123;true[self setAge:age];true[super setName:yourName];&#125;@end // PersonMe int main(int argc, char* argv[]) &#123;NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]PersonMe* me = [[PersonMe alloc] init];[me setName: @&quot;asdf&quot; andAge: 18];[me release];[pool drain];return 0;&#125; 上面有简单的两个类，在子类PersonMe中调用了自己类中的setAge和父类中的setName，这些代码看起来很好理解，没什么问题。 然后我在setName:andAge的方法中加入两行: 1234567891011NSLog(@&quot;self &apos; class is %@&quot;, [self class]);NSLog(@&quot;super&apos; class is %@&quot;, [super class]);``` 这样在调用时，会打出来这两个的**class**，先猜下吧，会打印出什么？ 按照以前*oop*语言的经验，这里应该会输出:***self &apos; s class is PersonMe super &apos; s class is Person***但是编译运行后，可以发现结果是：``` // self &apos;s class is PersonMesuper &apos; s class is PersonMe self的class和预想的一样，怎么super的class也是PersonMe? 真相self是类的隐藏的参数，指向当前当前调用方法的类，另一个隐藏参数是_cmd，代表当前类方法的selector。这里只关注这个self。super是个啥？super并不是隐藏的参数，它只是一个“编译器指示符”，它和self指向的是相同的消息接收者，拿上面的代码为例，不论是用[self setName]还是[super setName]，接收“setName”这个消息的接收者都是PersonMe* me这个对象。不同的是，super告诉编译器，当调用setName的方法时，要去调用父类的方法，而不是本类里的。 当使用self调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用superv时，则从父类**的方法列表中开始找。然后调用父类的这个方法。 One more step这种机制到底底层是如何实现的？其实当调用类方法的时候，编译器会将方法调用转成一个C函数方法调用，apple的objcRuntimeRef上说： Sending MessagesWhen it encounters a method invocation, the compiler might generate a call to any of several functions to perform the actual message dispatch, depending on the receiver, the return value, and the arguments. You can use these functions to dynamically invoke methods from your own plain C code, or to use argument forms not permitted by NSObject’s perform… methods. These functions are declared in /usr/include/objc/objc-runtime.h. objc_msgSend sends a message with a simple return value to an instance of a class. objc_msgSend_stret sends a message with a data-structure return value to an instance ofa class. objc_msgSendSuper sends a message with a simple return value to the superclass of an instance of a class. objc_msgSendSuper_stret sends a message with a data-structure return value to the superclass of an instance of a class. 可以看到会转成调用上面4个方法中的一个，由于_stret系列的和没有_stret的那两个类似，先只关注objc_msgSend和objc_msgSendSuper两个方法。 当使用[self setName]调用时，会使用objc_msgSend的函数，先看下objc_msgSend的函数定义: 1id objc_msgSend(id theReceiver, SEL theSelector, ...) 第一个参数是消息接收者，第二个参数是调用的具体类方法的selector，后面是selector方法的可变参数。我们先不管这个可变参数，以[self setName:]为例，编译器会替换成调用objc_msgSend的函数调用，其中theReceiver是self，theSelector是 @selector(setName:)，这个selector是从当前self的class的方法列表开始找的setName，当找到后把对应的 selector传递过去。 而当使用[super setName]调用时，会使用objc_msgSendSuper函数，看下objc_msgSendSuper的函数定义： 1id objc_msgSendSuper(struct objc_super *super, SEL op, ...) 第一个参数是个objc_super的结构体，第二个参数还是类似上面的类方法的selector，先看下objc_super这个结构体是什么东西： struct objc_super { id receiver; Class superClass; }; 可以看到这个结构体包含了两个成员，一个是receiver，这个类似上面objc_msgSend的第一个参数receiver，第二个成员是记 录写super这个类的父类是什么，拿上面的代码为例，当编译器遇到PersonMe里setName:andAge方法里的[super setName:]时，开始做这几个事: 构建objc_super的结构体，此时这个结构体的第一个成员变量receiver就是PersonMe* me，和self相同。而第二个成员变量superClass就是指类Person，因为PersonMe的超类就是这个Person。 调用objc_msgSendSuper的方法，将这个结构体和setName的sel传递过去。函数里面在做的事情类似这样：从objc_super结构体指向的superClass的方法列表开始找setName的selector，找到后再以 objc_super-&gt;receiver去调用这个selector，可能也会使用objc_msgSend这个函数，不过此时的第一个参数 theReceiver就是objc_super-&gt;receiver，第二个参数是从objc_super-&gt;superClass中找到 的selector 里面的调用机制大体就是这样了，以上面的分析，回过头来看开始的代码，当输出[self class]和[super class]时，是个怎样的过程。 当使用[self class]时，这时的self是PersonMe，在使用objc_msgSend时，第一个参数是receiver也就是self，也是 PersonMe* me这个实例。第二个参数，要先找到class这个方法的selector，先从PersonMe这个类开始找，没有，然后到PersonMe的父类 Person中去找，也没有，再去Person的父类NSObject去找，一层一层向上找之后，在NSObject的类中发现这个class方法，而 NSObject的这个class方法，就是返回receiver的类别，所以这里输出PersonMe。 当使用[super class]时，这时要转换成objc_msgSendSuper的方法。先构造objc_super的结构体吧，第一个成员变量就是self, 第二个成员变量是Person，然后要找class这个selector，先去superClass也就是Person中去找，没有，然后去Person 的父类中去找，结果还是在NSObject中找到了。然后内部使用函数objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用，此时已经和我们用[self class]调用时相同了，此时的receiver还是PersonMe* me，所以这里返回的也是PersonMe。 Furthor more 在类的方法列表寻找一个方法时，还牵涉到一个概念类对象的isa指针和objc的meta-class概念，这里就不再详细介绍。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"OC","slug":"OC","permalink":"http://codingdoge.cn/tags/OC/"},{"name":"转载","slug":"转载","permalink":"http://codingdoge.cn/tags/转载/"}]},{"title":"视频开发","slug":"title: 视频开发","date":"2017-07-23T15:47:00.000Z","updated":"2018-01-13T05:06:57.320Z","comments":true,"path":"2017/07/23/title: 视频开发/","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: 视频开发/","excerpt":"","text":"下面會介紹視頻的一些基本知識，和在iOS上實現視頻播放和緩存的幾種方案。 软解码和硬解码GPU解码就是所谓的硬解码，CPU解码就是软解码。iOS提供的播放器类使用的是硬解码，所以视频播放对CPU不会有很大的压力，但是支持的播放格式比较单一，一般就是MP4、MOV、M4V这几个。 HTTP Live StreamingHTTP Live Streaming（缩写是 HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。支持的视频流编码为H.264。我们在视频网站上看到的M3U8后缀的播放链接就是使用HLS协议的视频。HLS优点，1、看完一段缓存一段，防止只看一段视频但是把整个视频文件都缓存下来的用户，减少服务器压力和节省流量。2、根据用户网速切换不同的码率，兼顾流程性和清晰度。 播放实现视频播放的两个方案。 一、自己实现对数据编码解码可以在一些开源播放器上进行二次开发，如Bilibili的ijkplayer，或者直接对FFmpeg开发，优点在整个播放过程可控，为后续进行缓存、流量控制、码率切换等开发提供了基础，缺点是复杂，要求高，工程量大。 二、AVFoundationMedia Assets, Playback and Editing. 使用Apple自有框架。 AVAsset AVAsset is an abstract, immutable class used to model timed audiovisual media such as videos and sounds. An asset may contain one or more tracks that are intended to be presented or processed together, each of a uniform media type, including but not limited to audio, video, text, closed captions, and subtitles. Audiovisual media的资源类，通常通过AVURLAsset用URL来实例化，可以用Atom Inspector(一个Apple提供的用来查看视频信息的工具)来观察一个视频的属性，再去AVAsset中对应其属性。 AVAsset属性 视频文件属性 duration: CMTime duration, timescale时长和时间尺度 preferredRate: Float 默认速度 preferredVolume: Float 默认音量 creationDate: AVMetadataItem? 视频创建时间 tracks: [AVAssetTrack] 轨道 trackGroups: [AVAssetTrackGroup] 轨道组 lyrics: String? 当前语言环境合适的歌词 metadata: [AVMetadataItem] 元数据 AVPlayer An AVPlayer is a controller object used to manage the playback and timing of a media asset. It provides the interface to control the player’s transport behavior such as its ability to play, pause, change the playback rate, and seek to various points in time within the media’s timeline. You can use an AVPlayer to play local and remote file-based media, such as QuickTime movies and MP3 audio files, as well as audiovisual media served using HTTP Live Streaming. AVPlayer是一个控制对象用于管理媒体asset的播放，它提供了相关的接口控制播放器的行为，比如：播放、暂停、改变播放的速率、跳转到媒体时间轴上的某一个点（简单理解就是实现拖动功能显示对应的视频位置内容）。我们能够使用AVPlayer播放本地和远程的媒体文件（使用 HTTP Live Streaming），比如： QuickTime movies 和 MP3 audio files，所以AVPlayer可以满足音视频播放的基本需求。 AVFoundation的层次 AVPlayerItem AVPlayerItem models the timing and presentation state of an asset played by an AVPlayer object. It provides the interface to seek to various times in the media, determine its presentation size, identify its current time, and much more. AVPlayerItem是一个负责处理AVAsset的资源并通过AVPlayer来播放的载体，提供了seek、确定显示大小、ID、时间等的接口。 AVPlayerLayer AVPlayerLayer is a subclass of CALayer to which an AVPlayer object can direct its visual output. It can be used as the backing layer for a UIView or NSView or can be manually added to the layer hierarchy to present your video content on screen. 负责AVPlayer的视频输出展示。 依赖关系图 简单使用1234567891011class AVPlayerTestView: UIView &#123; let view: UIView? = nil func initPlayerView() &#123; guard let url = URL.init(string: &quot;http://meipu1.video.meipai.com/5e81c08e-2850-4fbd-bfc4-4ded297f9f1c.mp&quot;) else &#123; return &#125; let asset = AVAsset.init(url: url) let item = AVPlayerItem.init(asset: asset) let player = AVPlayer.init(playerItem: item) let playerLayer = AVPlayerLayer.init(layer: player) view?.layer.addSublayer(playerLayer) &#125;&#125; 设置好一个AVPlayer的依赖关系和输出图层后，AVPlayerItem会根据你的URL去请求数据，自己内部做缓冲然后播放。我们需要做的是用KVO监听AVPlayerItem内部几个关键属性的状态，然后做出我们的处理。 AVPlayerItem属性 状态 status: AVPlayerItemStatus .unknown: AVPlayerItemStatus 未知状态 .readyToPlay: AVPlayerItemStatus 准备好去播放 .failed: AVPlayerItemStatus 资源无法被播放 loadedTimeRanges: [NSValue] 加载了的资源的时间范围(一般用来更新缓冲UI) playbackBufferEmpty: Bool 没有缓冲数据 playbackLikelyToKeepUp: Bool 有足够的缓冲大致能播放无卡顿 General State Observations: You can use Key-value observing (KVO) to observe state changes to many of the player’s dynamic properties, such as its currentItem or its playback rate. You should register and unregister for KVO change notifications on the main thread. This avoids the possibility of receiving a partial notification if a change is being made on another thread. AVFoundation invokes observeValue(forKeyPath:of:change:context:) on the main thread, even if the change operation is made on another thread. 基本状态观察者：你能够使用KVO来观察player动态属性的状态改变，比如像： currentItem 或者它的播放速度。我们应该在主线程注册和去除KVO，这能够避免如果在其它线程发送改变而导致接收局部通知，当发生通知，AVFoundation将在主线程调用observeValue(forKeyPath:of:change:context:) 方法，即使是在其他线程发生。 KVO能够很好的观察生成的状态，但是并不能够观察播放时间的改变，所以AVPlayer提供了两个方法来观察时间的改变: 1234567891011/* @param interval 调用block的时间间隔 @param queue 推荐使用串行队列，放在主线程就行了，并行队列会产生不明确的结果*/func addPeriodicTimeObserver(forInterval interval: CMTime, queue: DispatchQueue?, using block: @escaping (CMTime) -&gt; Void) -&gt; Any &#123; // 可以在里面去设置控制状态，刷新进度UI&#125;func addBoundaryTimeObserver(forTimes times: [NSValue], queue: DispatchQueue?, using block: @escaping () -&gt; Void) -&gt; Any Tips: 创建多个AVPlayerLayer只有最近的layer才会显示视频帧 可以创建多个AVPlayerItem来替换AVPlayer的当前item，func replaceCurrentItem(with item: AVPlayerItem?) 监听后要注意控制监听的生命周期 缓存Apple自有的框架是没有提供缓存功能的，AVPlayer也没有提供直接获取其下载数据的接口，所以想做缓存只能自己来完整的实现。下面有几个方案。 一、自己实现的播放器这种情况大多是根据下载来的数据解码播放，下载的时候做下缓存就好了 二、自带播放器+LocalServer在iOS本地开启Local Server服务，然后MPMoviePlayerController请求本地Local Server服务。本地Local Server服务再不停的去对应的视频地址获取视频流。本地Local Server请求的时候，就可以把视频流缓存在本地。Demo来源:Code4App 三、AVPlayer+AVMutableComposition+AVAssetExportSession原理是直接给AVPlayer传URL，让其内部自己去处理数据下载，然后通过AVMutableComposition和AVAssetExportSession从AVAsset提取视频的数据进行缓存。 AVMutableComposition AVMutableComposition is a mutable subclass of AVComposition you use when you want to create a new composition from existing assets. You can add and remove tracks, and you can add, remove, and scale time ranges. 作用是从现有的AVAsset中创建出一个新的AVComposition，使用者能够从别的asset中提取他们的音频轨道或视频轨道，并且把它们添加到新建的composition中。 AVAssetExportSession An AVAssetExportSession object transcodes the contents of an AVAsset source object to create an output of the form described by a specified export preset. 作用是把AVAsset解码输出到本地文件中。 关键需要把原先的AVAsset(AVURLAsset)实现的数据提取出来后拼接成另一个AVAsset(AVComposition)的数据然后解码输出，由于通过网络url下载下来的视频没有保存视频的原始数据（苹果没有暴露接口给我们获取），下载后播放的avasset不能使用AVAssetExportSession输出到本地文件，要曲线地把下载下来的视频通过重构成另外一个AVAsset实例才能输出。 12345678910111213141516171819202122232425NSString *documentDirectory = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];NSString *myPathDocument = [documentDirectory stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@.mp4&quot;,[_source.videoUrl MD5]]];NSURL *fileUrl = [NSURL fileURLWithPath:myPathDocument];if (asset != nil) &#123;AVMutableComposition *mixComposition = [[AVMutableComposition alloc]init];AVMutableCompositionTrack *firstTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeVideo preferredTrackID:kCMPersistentTrackID_Invalid];[firstTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset.duration) ofTrack:[[asset tracksWithMediaType:AVMediaTypeVideo]objectAtIndex:0] atTime:kCMTimeZero error:nil];AVMutableCompositionTrack *audioTrack = [mixComposition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];[audioTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, asset.duration) ofTrack:[[asset tracksWithMediaType:AVMediaTypeAudio]objectAtIndex:0] atTime:kCMTimeZero error:nil];AVAssetExportSession *exporter = [[AVAssetExportSession alloc]initWithAsset:mixComposition presetName:AVAssetExportPresetHighestQuality];exporter.outputURL = fileUrl;if (exporter.supportedFileTypes) &#123;exporter.outputFileType = [exporter.supportedFileTypes objectAtIndex:0] ;exporter.shouldOptimizeForNetworkUse = YES;[exporter exportAsynchronouslyWithCompletionHandler:^&#123;&#125;];&#125;&#125; 四、AVPlayer+AVAssetResourceLoaderAVAssetResourceLoadingRequest An AVAssetResourceLoader object mediates resource requests from an AVURLAsset object with a delegate object that you provide. When a request arrives, the resource loader asks your delegate if it is able to handle the request and reports the results back to the asset.AVAssetResourceLoader协调来自AVURLAsset的资源请求，你需要实现它的delegate。当收到一个请求时，ResourceLoader询问你的delegate是否能处理并将结果返回给asset。 AVPlayer和AVAssetResourceLoader的层次结构 AVAssetResourceLoader通过你提供的委托对象去调节AVURLAsset所需要的加载资源。而很重要的一点是，AVAssetResourceLoader仅在AVURLAsset不知道如何去加载这个URL资源时才会被调用，就是说你提供的委托对象在AVURLAsset不知道如何加载资源时才会得到调用。一般我们可以更改URL的scheme用来隐藏真实的URL。如： 参考iOS开发系列–音频播放、录音、视频播放、拍照、视频录制AVplayer实现播放本地和网络视频（Swift3.0）iOS视频流开发（2）—视频播放iOS音频播放 (九)：边播边缓存iOS音视频实现边下载边播放AVFoundation(二)：核心AVAssetAVFoundation编程指南2-用AVPlayer播放视频AV Foundation系列（五）媒体组合","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://codingdoge.cn/tags/Swift/"}]},{"title":"有限状态机在iOS中的应用","slug":"title: 有限状态机在iOS中的应用","date":"2017-07-23T15:47:00.000Z","updated":"2018-01-13T05:06:26.865Z","comments":true,"path":"2017/07/23/title: 有限状态机在iOS中的应用/","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: 有限状态机在iOS中的应用/","excerpt":"","text":"有限状态机(Finite-State Machine, FSM)，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学模型。 其实我们平常和很多状态机都打过交道，比如正则表达式、网络协议（如TCP协议状态机）、游戏设计、字符串匹配等等，可能大多数时候我们都没意识到，接下来我们简略了解下状态机。 基本概念 状态(state): 指的是对象在其生命周期中的一种状况，处于某个特定状态中的对象必然会满足某些条件、执行某些动作或者是等待某些事件，而且状态是相对稳定的，如果没有外部条件的触发，一个状态会一直持续下去。 事件(event): 指的是对状态机来讲是有意义的那些事情。事件通常会引起状态的变迁，促使状态机从一种状态切换到另一种状态。 转换(transition): 指的是两个状态之间的一种关系，表明对象将在第一个状态中执行一定的动作，并将在某个事件发生的同时某个特定条件满足时进入第二个状态。 动作(action): 指的是状态机中可以执行的那些操作，当事件被满足或者状态变迁时执行动作，动作不是必需的。 如下图状态表： 关于状态机的详细知识可以参考：UML状态图的实用C/C++设计ERLANG 在iOS中的使用背景假设我们要设计一款网络视频播放器，有基本的播放、暂停功能，当缓冲好时可以进行播放，当URL错误或者视频资源错误时播放失败，我们发现，当我们去描述一个事物以及它的功能时，总是离不开它的状态，如这个播放器，我们可以定义它有播放失败、缓冲中、将要播放…等等状态。 设计我们可以用状态机去实现这样的功能。 先设定播放器可能出现的状态： 12345678enum VideoPlayerState &#123; case failed, // 播放失败 buffering, // 缓冲中 readyToPlay, // 将要播放 playing, // 播放中 paused, // 播放暂停 finished // 播放完毕&#125; 然后定义当状态发生变换后，针对某个状态我希望它去执行一些逻辑里的动作 1234567891011121314151617181920var state: VideoPlayerState = .paused &#123; didSet &#123; switch state &#123; case .failed: // 当视频加载失败时，我希望去执行的一些事件，比如弹出提示框 popReminderView() case .buffering: case .readyToPlay: case .playing: case .paused: case .finished: &#125; &#125;&#125; 在写我们的业务逻辑时，相应的去更改播放器的状态 123456// 比如我们重写网络层的一些方法，当缓冲好时准备播放networkRequestCompletion() &#123; state = .readyToPlay&#125; 这样，通过state我们能很清晰的知道现在播放器是什么样应该做什么事，在我们的业务逻辑中，当状态变化时通过didSet我们能很方便的去响应对应状态下应该执行的行为。 总结整篇文章质量或许不是很高，因为还没有大量的代码实践让我去有一个更深更全的体会，但是希望能带给我自己和读者们一点抛砖引玉的效果。我们在编码、设计过程中，多去思考一些，什么地方用什么样的模式更好，比如状态机，来使我们的代码更解耦，易维护，高扩展。 这里有一篇关于Objective-c状态机的实现，更抽象，其中用到的枚举值自动转字符串通用方案很有意思，同时可以参考这篇《iOS开发高级:使用宏定义macros》关于宏定义的使用。这篇《iOS APP 架构漫谈二》列举了很具体的运用场景，可以参考。同时参考的文章有： 有限状态机 有限状态机（FSM）的设计与实现 关于状态记的开源库推荐： Objective-C: TransitionKit Swift:SwiftTask","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[]},{"title":"Objective-C声明在头文件和实现文件中的区别","slug":"title: Objective-C声明在头文件和实现文件中的区别  ","date":"2017-07-23T15:47:00.000Z","updated":"2018-01-14T16:53:10.421Z","comments":true,"path":"2017/07/23/title: Objective-C声明在头文件和实现文件中的区别  /","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: Objective-C声明在头文件和实现文件中的区别  /","excerpt":"","text":"转自codecloud(有整理) 调试程序的时候，突然想到这个问题，百度一下发现有不少这方面的问答，粗略总结一下: 属性写在.h文件中和在.m文件中有什么区别? Objective-C中有分类和类扩展的概念，而实现文件中的类声明实际上就是类扩展. @interface部分为类扩展（extension） 其被设计出来就是为了解决两个问题的 定义类私有方法的地方，也就是下面说到的区别一 实现public readonly,private readwrite的property（意思是在h头文件中定义一个属性对外是readonly的，但在类的内部希望是可读写的，所以可以在m源文件中的@interface部分重新定义此属性为readwrite，此时此属性对外是只读的，对内是读写的）. 此外，也可在此部分申明变量和属性，但申明的变量，属性和方法均为私有的，只能够被当前类访问，相当于private。 区别一：属性在.h文件中和在.m中声明是有区别的。区别就是，在.h文件中声明的属性，外部类可以通过“类实例.属性”来调用，但在.m中声明的则不可以，获取和设置的方法，只能是通过setValue:forKey和valueForKey来实现。 成员变量，有三种权限，就是大家都知道的@private、@protected、@public ，写在.m文件中时，相当于是@private权限，子类无法访问，验证了一下，做权限修改也无效。而写在.h文件中，默认是@protected权限，子类可以访问，可以做权限修改。因为访问权限指针对.h文件。.h文件中成员变量，外部类对其的调用，跟C++一样，用-&gt;来调用。 区别二这样可以提高编译效率，避免重复编译。因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大提高了效率。这样可以提高编译效率，避免重复编译. 怎么去解释呢…其实这是一个面向对象的思想，所谓”提高”的比较对象，应该是直接将方法写到具体函数里的实现方式.h为编译器提供一个索引、声明，连接obj对象和主程序.编译器在编译的时候，如果需要，则去查找h，找到了h，再找对应的obj，就可以找到类的方法了.但是如果直接写入到同一个文件（例如hpp），主程序没有索引，也不清楚具体的类实现了没有，只能一次次重复的编译相同的代码，这样实际上没有把这个类该有的东西抽象出来.对于函数声明在头文件中，在实现文件中实现，也是避免重复编译，函数可以多次声明，但只能实现一次. 头文件相对于实现文件的作用在于: 头文件可以预先告诉编译器一些必要的声明,让编译器顺利进行下去,在连接实现以前.未必出现实际的定义. 头文件的意义在: * 使得程序简明,清晰. * 避免了重复编写相同的声明代码. .c和.h文件没有必然的联系. 关于头文件和实现文件的编译连接的过程其实要理解C文件与头文件有什么不同之处，首先需要弄明白编译器的工作过程，一般说来编译器会做以下几个过程: 预处理阶段 词法与语法分析阶段 编译阶段，首先编译成纯汇编语句，再将之汇编成跟CPU相关的二进制码，生成各个目标文件 连接阶段，将各个目标文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件，当然，最后还可以用objcopy生成纯二进制码，也就是去掉了文件格式信息. 编译器在编译时是以C文件为单位进行的，也就是说如果你的项目中一个C文件都没有，那么你的项目将无法编译，连接器是以目标文件为单位，它将一个或多个目标文件进行函数与变量的重定位，生成最终的可执行文件，在PC上的程序开发，一般都有一个main函数，这是各个编译器的约定，当然，你如果自己写连接器脚本的话，可以不用main函数作为程序入口！！！ 有了这些基础知识，再言归正传，为了生成一个最终的可执行文件，就需要一些目标文件，也就是需要C文件，而这些C文件中又需要一个main函数作为可执行程序的入口，那么我们就从一个C文件入手，假定这个C文件内容如下： 12345678#include \\&lt;stdio.h&gt;#include “mytest.h”int main(int argc,char **argv)&#123;test = 25;printf(“test……………..%d\\n”,test);&#125; 头文件内容如下:int test; 现在以这个例子来讲解编译器的工作: 预处理阶段:编译器以C文件作为一个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会将相应头文件中再去处理宏，变量，函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件中，形成一个中间“C文件” 编译阶段:在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件 连接阶段:将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件，主要的工作就是重定位各个目标文件的函数，变量等，相当于将个目标文件中的二进制码按一定的规范合到一个文件中 再回到C文件与头文件各写什么内容的话题上：理论上来说C文件与头文件里的内容，只要是C语言所支持的，无论写什么都可以的，比如你在头文件中写函数体，只要在任何一个C文件包含此头文件就可以将这个函数编译成目标文件的一部分（编译是以C文件为单位的，如果不在任何C文件中包含此头文件的话，这段代码就形同虚设），你可以在C文件中进行函数声明，变量声明，结构体声明，这也不成问题！！！那为何一定要分成头文件与C文件呢？又为何一般都在头件中进行函数，变量声明，宏声明，结构体声明呢？而在C文件中去进行变量定义，函数实现呢？？原因如下: 如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错 如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间 如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一下头文件就行了 在头文件中声明结构体，函数等，当你需要将你的代码封装成一个库，让别人来用你的代码，你又不想公布源码，那么人家如何利用你的库呢？也就是如何利用你的库中的各个函数呢？？一种方法是公布源码，别人想怎么用就怎么用，另一种是提供头文件，别人从头文件中看你的函数原型，这样人家才知道如何调用你写的函数，就如同你调用printf函数一样，里面的参数是怎样的？？你是怎么知道的？？还不是看人家的头文件中的相关声明啊！！！当然这些东东都成了C标准，就算不看人家的头文件，你一样可以知道怎么使用.","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"OC","slug":"OC","permalink":"http://codingdoge.cn/tags/OC/"},{"name":"转载","slug":"转载","permalink":"http://codingdoge.cn/tags/转载/"}]},{"title":"xcode常用快捷键及其他功能","slug":"title: xcode常用快捷键及其他功能","date":"2017-07-23T15:47:00.000Z","updated":"2018-01-13T05:05:53.756Z","comments":true,"path":"2017/07/23/title: xcode常用快捷键及其他功能/","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: xcode常用快捷键及其他功能/","excerpt":"","text":"快捷键 Command+R生成并运行程序Command+B只生成程序而不运行它Command+T新建选项卡 标记 // MARK: - \\// TODO: \\// FIXME: \\ 小功能 Product&gt;Clean删除生成的中间文件","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://codingdoge.cn/tags/Tool/"}]},{"title":"OC中ARC forbids explicit message send of '...'错误","slug":"title: OC中ARC forbids explicit message send of '...'错误  ","date":"2017-07-23T15:25:00.000Z","updated":"2018-01-14T17:00:06.700Z","comments":true,"path":"2017/07/23/title: OC中ARC forbids explicit message send of '...'错误  /","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: OC中ARC forbids explicit message send of '...'错误  /","excerpt":"","text":"转自CSDN hahahacff有所整理 ARC forbids explicit message send of’retainCount’ 同’release’等等 很显然，是ARC的问题。错误原因：在创建工程的时候点选了“Use Automatic Reference Counting”选项,但是又调用了对象的retainCount方法 ARC是什么?ARC是iOS 5推出的新功能，全称叫ARC(AutomaticReferenceCounting)。简单地说，就是代码中自动加入了retain/release，原先需要手动添加的用来处理内存管理的引用计数的代码可以自动地由编译器完成了。该机制在iOS 5/ Mac OS X 10.7 开始导入，利用 Xcode4.2可以使用该机制。简单地理解ARC，就是通过指定的语法，让编译器(LLVM3.0)在编译代码时，自动生成实例的引用计数管理部分代码。有一点，ARC并不是GC，它只是一种代码静态分析（StaticAnalyzer）工具。 解决方法 选择要项目，双击中间的工程名称，进入build setting 将中间的Objective-C Automatic Reference Counting改为no","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"http://codingdoge.cn/tags/Bug/"},{"name":"OC","slug":"OC","permalink":"http://codingdoge.cn/tags/OC/"},{"name":"转载","slug":"转载","permalink":"http://codingdoge.cn/tags/转载/"}]},{"title":"解决Arduino CH34x系列在macOS Sierra中找不到串口的问题","slug":"title: 解决Arduino CH34x系列在macOS Sierra中找不到串口的问题","date":"2017-07-23T15:06:00.000Z","updated":"2018-01-12T14:23:28.810Z","comments":true,"path":"2017/07/23/title: 解决Arduino CH34x系列在macOS Sierra中找不到串口的问题/","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: 解决Arduino CH34x系列在macOS Sierra中找不到串口的问题/","excerpt":"","text":"毕设做Arduino开发，一开始买了淘宝上慧净自己改的Arduino UNO国产板子，回来插在mac上读不出串口，安装了它附带的驱动还是读不出，同学买了原装板说一插上就能读出串口，都没自己装驱动，为了省麻烦，直接跟商家换了原装板，这时候麻烦来了，板子在我电脑上读不出串口，在别人电脑上能读出来，别人的在我电脑上也读不出来…很崩溃，然后从各个角度debug，下面一个个步骤来，基本能解决。 安装Arduino IDE上面是官网IDE下载的连接，大概是因为GFW的原因下载速度奇慢，大家也可以去搜Arduino中文社区，里面有好人做了*度网盘的下载种子，速度能快点。IDE一般自带驱动，如果在串口里没发现，可以试试在 D7389412-ED23-427D-82E7-4E1C26114D67 这个系统报告里看看USB下面能不能读出 也可以在bash里输入 1ls /dev/tty* 如果有类似的即可 2C66575E-D0DD-4DEA-9F34-8F2E1CF4DA90 官方驱动下载如果都找不到的话可以去沁恒官方下载CH341SER驱动，安装后再查看一遍(安装驱动完会要求重启). 更改SIP设置 Apple在10.11中全面启用了名为 System Integrity Protection (SIP) 的系统完整性保护技术. 受此影响, 未经签名的第三方kext及经过修改的原版kext将无法正常加载, 大部分系统文件即使在root用户下也无法直接进行修改. 前面安装驱动不成功大部分是因为驱动文件冲突导致，所以在此之前先删除之前安装的驱动文件: 123sudo rm -rf /System/Library/Extensions/usb.kextsudo rm -rf /Library/Extensions/usbserial.kextsudo rm -rf _private_var_db_receipts/com.wch.* 然后参考CH340 CH341 serial adapters fix for El Capitan OS X可以通过以下步骤修改SIP设置来安装第三方kext: 重启OS X 并且立即按住 Command+ R 来来进入恢复模式 在恢复模式中, 菜单栏上面找到终端(Terminal)并打开 在终端中键入命令csrutil enable —without kext 看到成功的提示信息之后, 输入reboot重启系统 注: —without kext 中的 - 有两条Command 就是 ⌘ 图标 通过以上的操作之后, 采用CH340/1 系列芯片的Arduino开发板又可以被识别出来了. 如果还是无法识别, 请重新安装一次CH341SER驱动. 最后如果还不行(我的就是到这里还不行)，请看看你的板子是否接触不良，反复摩擦尝试看能不能读出串口，我之前也试过这个办法，但是没有用，后面偶然也是必然下反应过来，反反复复插USB拔出查看串口状态，终于解决了(无良商家害人) 参考:如何重置 Mac 上的 NVRAM","categories":[{"name":"OS","slug":"OS","permalink":"http://codingdoge.cn/categories/OS/"}],"tags":[{"name":"Bug","slug":"Bug","permalink":"http://codingdoge.cn/tags/Bug/"}]},{"title":"《TCP/IP详解》笔记—第1章 概述","slug":"title: 《TCP-IP详解》笔记—第1章 概述","date":"2017-07-23T15:04:00.000Z","updated":"2018-01-12T14:22:22.232Z","comments":true,"path":"2017/07/23/title: 《TCP-IP详解》笔记—第1章 概述/","link":"","permalink":"http://codingdoge.cn/2017/07/23/title: 《TCP-IP详解》笔记—第1章 概述/","excerpt":"","text":"《TCP/IP详解》笔记—第1章 概述 一个互连网就是一组通过相同协议族互连在一起的网络。 分层TCP/IP通常被认为是一个四层协议系统: WX20170320-171317@2x 网络层和运输层之间的区别是最为关键的：网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务。 在TCP/IP协议族中，网络层IP提供的是一种不可靠的服务。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。 路由器为不同类型的物理网络提供连接。 一个主机也可以有多个接口，但一般不称作路由器,除非它的功能只是单纯地把分组从一个接口传送到另一个接口。 互联网的目的之一是在应用程序中隐藏所有的物理细节。 连接网络的另一个途径是使用网桥。网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连。 互联网的地址 47F26D90-176D-4C0A-A315-6A9E199E79F6 这些 32 位的地址通常写成四个十进制的数,其中每个整数对应一个字节。这种表示方法称作“点分十进制表示法(Dotted decimal notation)”。 70807FBE-712D-4A5C-97F2-BBCA12C1F11D 封装TCP传给IP的数据单元称作TCP报文段或简称为TCP段（TCP segment）。IP传给网络接口层的数据单元称作IP数据报(IP datagram)。通过以太网传输的比特流称作帧(Frame)。 分用当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。 客户-服务器模型大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。一般来说，TCP服务器是并发的，而UDP服务器是重复的。 习题 请计算最多有多少个A类、B类和C类网络号。 用匿名FTP（见27.3节）从主机nic.merit.edu上获取文件nsfnet_statistics_history.netcount。该文件包含在NSFNET网络上登记的国内和国外的网络数。画一坐标系，横坐标代表年，纵坐标代表网络总数的对数值。纵坐标的最大值是习题1.1的结果。如果数据显示一个明显的趋势，请估计按照当前的编址体制推算，何时会用完所有的网络地址（3.10节讨论解决该难题的建议）。 获取一份主机需求RFC拷贝[Braden 1989a]，阅读有关应用于TCP/IP协议族每一层的稳健性原则。这个原则的参考对象是什么？ 获取一份最新的赋值RFC拷贝。“quote of the day”协议的有名端口号是什么？哪个RFC对该协议进行了定义？ 如果你有一个接入TCP/IP互联网的主机帐号，它的主IP地址是多少？这台主机是否接入了Internet？它是多接口主机吗？ 获取一份RFC 1000的拷贝，了解RFC这个术语从何而来。 与Internet协会联系，isoc@isoc.org或者+170 3648 9888，了解有关加入的情况。 用匿名FTP从主机is.internic.net处获取文件about-internic/information-about-the-internic。 部分习题答案 答案是：27-2（126）＋214-2（16 382）＋221-2（2 097 150）=2 113 658。每一部分都减去2是因为全0或全1网络ID是非法的。 图D-1显示了直到1993年8月的有关数据。如果网络数继续呈指数增长的话，虚线估计了2000年可能达到的最大的网络数。 “自由地接收，保守地发送。” 资料来源于 即时通讯网，仅做学习参考","categories":[{"name":"Network","slug":"Network","permalink":"http://codingdoge.cn/categories/Network/"}],"tags":[{"name":"Reading Notes","slug":"Reading-Notes","permalink":"http://codingdoge.cn/tags/Reading-Notes/"}]},{"title":"STL常见用法 — map","slug":"title: STL常见用法 — map","date":"2017-07-21T05:10:00.000Z","updated":"2018-01-14T17:04:04.187Z","comments":true,"path":"2017/07/21/title: STL常见用法 — map/","link":"","permalink":"http://codingdoge.cn/2017/07/21/title: STL常见用法 — map/","excerpt":"","text":"STL常见用法 — 代码敲得少，STL总是用的不熟，便自己整理一些用法，有眼缘的顺手用着吧。 简介maps是一个关联容器，用来存储key-value式的元素，提供一对一hash。内部的实现，自建一颗红黑树，这棵树具有对数据自动排序的功能。比如一个班级中，每个学生的学号和他的姓名就存在一对一映射的关系。 第一个值是关键字(key)，每个关键字只能在map中出现一次 第二个值为关键字的值(value) 用法头文件12345678#include &lt;map&gt;template&lt; class Key, class T, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;&gt; class map; 构造函数12345namespace pmr &#123; template &lt;class Key, class T, class Compare = std::less&lt;Key&gt;&gt; using map = std::map&lt;Key, T, Compare, std::pmr::polymorphic_allocator&lt;std::pair&lt;const Key,T&gt;&gt;&gt;&#125; 成员函数 成员函数 实现操作 begin 返回一个起始的迭代器 end 返回一个末尾的迭代器 empty 检查容器是否为空 size 返回容器内元素个数 clear 清除容器内容 insert 插入元素或节点 erase 删除元素 swap 交换内容 count 返回指定key的元素个数 find 通过key查找元素 用法演示1234567891011121314151617181920#include &lt;map&gt;void mapTest()&#123; std::map&lt;int, int&gt; m; // 构造函数 m.insert(pair&lt;int, int&gt;(1, 10)); // 插入元素 m.insert(pair&lt;int, int&gt;(2, 30)); m.insert(pair&lt;int, int&gt;(4, 50)); map&lt;int, int&gt;::iterator it; // 迭代器 it = m.find(3); // 通过key查找元素 if (it == m.end()) // 如果返回值为尾部迭代器则无此元素 &#123; cout &lt;&lt; &quot;Not find&quot; &lt;&lt; endl; m.insert(pair&lt;int, int&gt;(3, 20)); &#125; for (it = m.begin(); it != m.end(); it++) // 通过迭代器遍历map容器 &#123; cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; endl; // 通过迭代器访问元素的key-value &#125;&#125; 参考:C/C++ - Map (STL) 用法與心得完全攻略","categories":[{"name":"CPP","slug":"CPP","permalink":"http://codingdoge.cn/categories/CPP/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://codingdoge.cn/tags/STL/"}]},{"title":"STL常见用法 — vector","slug":"title: STL常见用法 — vector","date":"2017-07-21T05:06:00.000Z","updated":"2018-01-14T17:04:41.751Z","comments":true,"path":"2017/07/21/title: STL常见用法 — vector/","link":"","permalink":"http://codingdoge.cn/2017/07/21/title: STL常见用法 — vector/","excerpt":"","text":"代码敲得少，STL总是用的不熟，便自己整理一些用法，有眼缘的顺手用着吧。 简介vector是线性容器,它的元素严格的按照线性序列排序,和动态数组很相似,和数组一样,它的元素存储在一块连续的存储空间中,这也意味着我们不仅可以使用迭代器(iterator)访问元素,还可以使用指针的偏移方式访问,和常规数组不一样的是,vector能够自动存储元素,可以自动增长或缩小存储空间。 用法头文件1#include &lt;vector&gt; 构造函数12345678// 1template&lt;class T, class Allocator = std::allocator&lt;T&gt; &gt; class vector;// 2namespace pmr &#123; template &lt;class T&gt; using vector = std::vector&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt;;&#125; std::vector is a sequence container that encapsulates dynamic size arrays. std::pmr::vector is an alias template that uses a polymorphic allocator 成员函数 成员函数 实现操作 c.assign(beg,end) 将[beg; end)区间中的数据赋值给c c.assign(n,elem) 将n个elem的拷贝赋值给c c.at(idx) 传回索引idx所指的数据，如果idx越界，抛出out_of_range c.back() 传回最后一个数据，不检查这个数据是否存在 c.begin() 传回迭代器重的可一个数据 c.capacity() 返回容器中数据个数 c.clear() 移除容器中所有数据 c.empty() 判断容器是否为空 c.end() 指向迭代器中的最后一个数据地址 c.erase(pos) 删除pos位置的数据，传回下一个数据的位置 c.erase(beg,end) 删除[beg,end)区间的数据，传回下一个数据的位置 c.front() 传回第一个数据 get_allocator 使用构造函数返回一个拷贝 c.insert(pos,elem) 在pos位置插入一个elem拷贝，传回新数据位置 c.insert(pos,n,elem) 在pos位置插入n个elem数据。无返回值 c.insert(pos,beg,end) 在pos位置插入在[beg,end)区间的数据。无返回值 c.max_size() 返回容器中最大数据的数量 c.pop_back() 删除最后一个数据 c.push_back(elem) 在尾部加入一个数据 c.rbegin() 传回一个逆向队列的第一个数据 c.rend() 传回一个逆向队列的最后一个数据的下一个位置 c.resize(num) 重新指定队列的长度 c.reserve() 保留适当的容量 c.size() 返回容器中实际数据的个数 c1.swap(c2) 将c1和c2元素互换 swap(c1,c2) 同上操作 vector c 创建一个空的vector vector c1(c2) 复制一个vector vector c(n) 创建一个vector，含有n个数据，数据均已缺省构造产生 vector c(n, elem) 创建一个含有n个elem拷贝的vector。 vector c(beg,end) 创建一个以[beg;end)区间的vector c.~ vector () 销毁所有数据，释放内存 用法演示 使用reverse将元素翻转:需要头文件#include&lt;algorithm&gt; 1reverse(vec.begin(),vec.end()); 将元素翻转(在vector中，如果一个函数中需要两个迭代器，一般后一个都不包含) 使用sort排序:需要头文件#include，sort(vec.begin(),vec.end());(默认是按升序排列,即从小到大).可以通过重写排序比较函数按照降序比较，如下: 定义排序比较函数: 1234bool Comp(const int &amp;a,const int &amp;b)&#123; return a&gt;b;&#125; 调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。","categories":[{"name":"CPP","slug":"CPP","permalink":"http://codingdoge.cn/categories/CPP/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://codingdoge.cn/tags/STL/"}]},{"title":"常用宏定义","slug":"title: 常用宏定义","date":"2017-07-17T06:08:00.000Z","updated":"2018-01-13T05:07:28.710Z","comments":true,"path":"2017/07/17/title: 常用宏定义/","link":"","permalink":"http://codingdoge.cn/2017/07/17/title: 常用宏定义/","excerpt":"","text":"iOS开发高级:使用宏定义macros 123456789101112131415161718192021222324252627282930313233343536373839404142434445//1. 打印日志#ifdef DEBUG# define DLog(...) NSLog(__VA_ARGS__)#else# define DLog(...)#endif//2. 获取屏幕 宽度、高度#define kScreenWidth ([UIScreen mainScreen].bounds.size.width)#define kScreenHeight ([UIScreen mainScreen].bounds.size.height)//3. 颜色#define RGB(r, g, b, a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]#define HEXCOLOR(c) [UIColor colorWithRed:((c&gt;&gt;16)&amp;0xFF)/255.0f green:((c&gt;&gt;8)&amp;0xFF)/255.0f blue:(c&amp;0xFF)/255.0f alpha:1.0f]//背景色 #define BACKGROUND_COLOR [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0] //清除背景色 #define CLEARCOLOR [UIColor clearColor] //4.加载图片宏：#define LOADIMAGE(file,type) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:file ofType:type]]//5. NavBar高度#define NavigationBar_HEIGHT 44//6. 获取系统版本#define IOS_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]#define CurrentSystemVersion [[UIDevice currentDevice] systemVersion]//7. 判断是真机还是模拟器#if TARGET_OS_IPHONE //iPhone Device#endif#if TARGET_IPHONE_SIMULATOR //iPhone Simulator#endif//8. 设置View的tag属性#define VIEWWITHTAG(_OBJECT, _TAG) [_OBJECT viewWithTag : _TAG]//9. GCD#define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)#define MAIN(block) dispatch_async(dispatch_get_main_queue(),block)//10. NSUserDefaults 实例化#define USER_DEFAULT [NSUserDefaults standardUserDefaults]","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"OC","slug":"OC","permalink":"http://codingdoge.cn/tags/OC/"}]},{"title":"STL常见用法 — queue","slug":"title: STL常见用法 — queue","date":"2017-07-17T03:19:00.000Z","updated":"2018-01-14T17:04:46.168Z","comments":true,"path":"2017/07/17/title: STL常见用法 — queue/","link":"","permalink":"http://codingdoge.cn/2017/07/17/title: STL常见用法 — queue/","excerpt":"","text":"代码敲得少，STL总是用的不熟，便自己整理一些用法，有眼缘的顺手用着吧。 简介 队列(queue)是一种特殊的线性表，是一种先进先出(First In First Out)的数据结构，允许在队列末尾插入元素，队列头取出元素，在STL中是用list或者deque实现，封闭头部即可。 用法头文件1#include &lt;queue&gt; 构造函数1template &lt;class T, class Container = deque&lt;T&gt; &gt; class queue; 队列适配器默认用deque容器实现，也可以指定使用list容器来实现 123queue &lt;Elem&gt; q; // 创建一个空的queue，默认使用deque容器queue &lt;Elem, list&lt;Elem&gt; &gt; q; // 使用list容器queue &lt;Elem&gt; q1(q2); // 复制q2 成员函数 成员函数 实现操作 Elem&amp; back() 返回队列最后一个元素 bool empty()const 如果队列为空，返回true，否则返回false Elem&amp; front() 返回队列第一个元素 void pop() 移除队列中的第一个元素 void push(const Elem&amp; e) 在队列末尾插入元素e size_type size()const 返回队列中的元素数目 用法演示1234567891011121314151617181920212223#include &lt;stdio.h&gt; #include &lt;queue&gt; using namespace std; int main() &#123; int n, m, size; queue &lt;int&gt; q; //定义队列q q.push(1); q.push(2); //将1 、2压入队列 while (!q.empty()) //判断队列是否为空 &#123; n = q.front(); //返回队列头部数据 m = q.back(); //返回队列尾部数据 size = q.size(); //返回队列里的数据个数 q.pop(); //队列头部数据出队 printf(\"%d %d %d\\n\", n, m, size); &#125; return 0; &#125;","categories":[{"name":"CPP","slug":"CPP","permalink":"http://codingdoge.cn/categories/CPP/"}],"tags":[{"name":"STL","slug":"STL","permalink":"http://codingdoge.cn/tags/STL/"}]},{"title":"插件管理——Vundle","slug":"title: 插件管理——Vundle","date":"2017-07-17T03:18:00.000Z","updated":"2018-01-14T17:19:40.848Z","comments":true,"path":"2017/07/17/title: 插件管理——Vundle/","link":"","permalink":"http://codingdoge.cn/2017/07/17/title: 插件管理——Vundle/","excerpt":"","text":"都说Vim是程序员写给自己的编辑器，其中的情结可想而知。 vim因为其庞大而强劲的插件受到无比的推崇，而插件的查找和管理便成了一个问题。 Vundle便是一个Github上为了解决这个问题的项目(致敬贡献者们)，使用步骤如下： 安装Vundle，在终端输入以下代码即可git clone http://github.com/gmarik/vundle.git ~/.vim/bundle/vundle ~/.vim 来自哪?在mac中Vim配置文件.vimrc在/usr/share/vim/下，一般是没有权限更改的,但是这个.vimrc是全局配置文件，我们只要更改用户配置文件即可 怎么查看/usr/? 显示隐藏文件，自行百度，终端中敲入代码即可。 Finder下或者桌面上的Go，文件夹输入/usr/。mac下的Vim用户配置文件默认是没有的，需要我们自行创建终端下输入123&gt; mkdir ~/.vim&gt; touch ~/.vimrc&gt; ~/即为用户根目录。 在Vim Script选好插件在.vimrc文件中加一句Bundle plugin_name.vimrc示例:1234567891011set nocompatible \" be iMprovedfiletype off \" required!set rtp+=~/.vim/bundle/vundle/call vundle#rc()\" let Vundle manage Vundle\" required!Bundle 'gmarik/vundle'\" vim-scripts reposBundle 'vim-plugin-foo'Bundle 'vim-plugin-bar'filetype plugin indent on \" required! 执行Vundle安装命令1:BundleInstall Vundle的其它命令 :BundleList 列举出列表中(.vimrc中)配置的所有插件 :BundleInstall 安装列表中全部插件 :BundleInstall! 更新列表中全部插件 :BundleSearch foo 查找foo插件 :BundleSearch! foo 刷新foo插件缓存 :BundleClean 清除列表中没有的插件 :BundleClean! 清除列表中没有的插件 参考Git时代的VIM不完全使用教程使用Vundle来管理vim的插件zhongcq 的VIM配置","categories":[{"name":"Shell","slug":"Shell","permalink":"http://codingdoge.cn/categories/Shell/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://codingdoge.cn/tags/Tool/"}]},{"title":"漫谈iOS系列之：内存管理","slug":"title: 漫谈iOS系列之：内存管理","date":"2017-07-17T03:18:00.000Z","updated":"2018-01-14T14:05:07.599Z","comments":true,"path":"2017/07/17/title: 漫谈iOS系列之：内存管理/","link":"","permalink":"http://codingdoge.cn/2017/07/17/title: 漫谈iOS系列之：内存管理/","excerpt":"","text":"引用计数推荐一篇来自@杨萧玉的引用计数原理Blog 简介iOS中对内存管理的机制（堆内存），每一个对象都有一个与之关联的引用计数（Reference Counting）。当一个对象“被拥有”的时候引用计数+1，当一个对象引用计数为零时该对象被释放。 比拟比如上班，最早进入办公室的人需要开灯，之后进入办公室的人需要照明， 下班离开办公室的人不需要照明，最后离开办公室的人需要关灯。这样对应的引用计数就是：第一个人进入办公室开灯，引用计数是1。之后进入办公室需要照明引用计数是2。下班一个人离开办公室引用计数变成了1，最后一个离开了办公室，引用计数变成了0 。 引用计数如何储存 TaggedPointer一篇极好的文章总体来说，我的理解是如果一个对象使用了Tagged Pointer技术（比如NSString，NSNumber等），指针里面会直接存数据内容，不会再作为“指针”指向其它地址，从Runtime来理解就是不会使用isa指针，也就不会继承苹果的内存管理方式（Reference Counting）。判断当前对象是否在使用 TaggedPointer 是看标志位是否为1: 12345678910111213#if SUPPORT_MSB_TAGGED_POINTERS# define TAG_MASK (1ULL&lt;&lt;63)#else# define TAG_MASK 1inline bool objc_object::isTaggedPointer() &#123;#if SUPPORT_TAGGED_POINTERS return ((uintptr_t)this &amp; TAG_MASK);#else return false;#endif&#125; isa 指针指针的内存空间很大，有时候可以优化指针，在指针中存储一部分内容。下面列出不同架构下的64位环境中isa指针结构: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;#if SUPPORT_NONPOINTER_ISA# if __arm64__# define ISA_MASK 0x00000001fffffff8ULL# define ISA_MAGIC_MASK 0x000003fe00000001ULL# define ISA_MAGIC_VALUE 0x000001a400000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000 uintptr_t magic : 9; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;;# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x0000000000000001ULL# define ISA_MAGIC_VALUE 0x0000000000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 14;# define RC_ONE (1ULL&lt;&lt;50)# define RC_HALF (1ULL&lt;&lt;13) &#125;;# else // Available bits in isa field are architecture-specific.# error unknown architecture# endif// SUPPORT_NONPOINTER_ISA#endif&#125;; 只有arm64架构的设备支持优化，下面列出了isa指针中变量对应的含义: 变量名 含义 indexed 0 表示普通的isa指针，1 表示使用优化，存储引用计数 has_assoc 表示该对象是否包含 associated object，如果没有，则析构时会更快 has_cxx_dtor 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快 shiftcls 类的指针 magic 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化 weakly_referenced 表示该对象是否有过weak对象，如果没有，则析构时更快 deallocating 表示该对象是否正在析构 has_sidetable_rc 表示该对象的引用计数值是否过大无法存储在isa指针 extra_rc 存储引用计数值减一后的结果 散列表散列表来存储引用计数具体是用DenseMap类来实现，实现中有锁保证其安全性。 获取引用计数在MRC环境下可以使用retainCount方法获取某个对象的引用计数。在ARC环境下可以使用Core Foundation 库的CFGetRetainCount((__bridge CFTypeRef)(obj))方法和Runtime的_objc_rootRetainCount()方法来获取引用计数，也可以使用KVC技术来获取valueForKey:@&quot;retainCount&quot;。注意以上方法不是线程安全的。 注意NSString 定义的对象是保存在字符串常量区，没有用引用计数管理内存，如果输出其retainCount，为-1。 retainCount 注意其中的Do not use this method。 MRC(Manual Reference Counting) MRC从字面上理解就是手动管理引用计数，也就是手动管理内存。相关的内存管理方法有retain，release，autorelease，其中retain方法是对引用计数+1，相应的release是对引用计数-1，autorelease是将对象加入自动释放池，下文会讲到。 示例代码 1234567// 以预定Person类为例Person* person = [[Person alloc] init]; // 申请对象，此时引用计数=1[person retain]; //此时引用记数+1，现为2[person release]; //引用计数-1，此时引用计数=1[person release]; //引用计数-1，此时引用计数=0，内存被释放[person autorelease]; // 将对象加入自动释放池Person *person = [[[Person alloc] init] autorelease]; // 也可以在创建对象时将其加入自动释放池 按道理来说创建一个对象，然后release后该对象引用计数为零，但是实际情况中并不会出现这种现象，release后再输出其引用计数还是为1，在我的理解中有两种可能： 该对象在引用计数为1的时候进行release后，对象已经被释放，此时再调用retainCount毫无意义，因为该对象已经不存在了，为了防止某些错误保护这个retainCount方法所以编译器不会报错，但是输出值为释放前的值； 编译器为我们做了各种优化，也许是记录retainCount为零消耗过大或者没有意义。 重写了`dealloc`方便查看对象是否被释放 输出其`retainCount`然后释放 可以看到并不会出现引用计数为零的情况，但是该对象确实被释放了 小知识:指针错误：访问了一块坏的内存（已经被回收的，不可用的内存）。僵尸对象：所占内存已经被回收的对象，僵尸对象不能再被使用。（打开僵尸对象检测）空指针：没有指向任何东西的指针（存储的东西是0, null, nil），给空指针发送消息不会报错。注意：不能使用[p retaion]让僵尸对象起死复生。 在MRC管理时代有一个黄金法则： 谁创建谁负责。如果你通过alloc,new,copy来创建了一个对象，那么你就必须调用release或者autorelease方法； 谁retain，谁release。只要你调用了retain，无论这个对象时如何生成的，你都要调用release； ARC 原理前段编译器会为“拥有的”每一个对象加入相应的release语句，如果对象的所有权修饰符是__strong，那么它就是被拥有的。如果再某个方法内创建了一个对象，前端编译器会在方法末尾自动插入release语句已销毁它。而类拥有的对象（实例变量/属性）会在dealloc方法内被释放。 编译器所为 编译器为我们做的，我们可以手动完成达到优化比如：__autoreleasing在ARC中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下，有这种指针（NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为__autoreleasing类型。比如常用的NSError的使用： 12345NSError *__autoreleasing error;if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error])&#123; NSLog(@\"Error: %@\", error);&#125; 如果你把error定义为了strong型，编译器会隐式地做如下事情，保证最终传入函数的参数依然是个__autoreleasing类型的引用。 1234567NSError *error;NSError *__autoreleasing tempError = error; // 编译器添加if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError])&#123; error = tempError; // 编译器添加 NSLog(@\"Error :%@\", error);&#125; 所以为了提高效率，避免这种情况，我们一般在定义error的时候将其老老实实地声明为__autoreleasing类型。 循环引用 平常我们容易造成循环引用的三种情况： NSTimer 先看NSTimer使用的代码: 1_timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(runTimer) userInfo:nil repeats:YES]; 其中_timer是实例变量被self保留，_timer的target是self，self被_timer保留，引发循环引用。 循环引用 解除方法就是使target中的对象不是viewController从而断开引用，iOS10之前我们可以写个类别重新封装target来实现，iOS10之后系统给了新方法： 1+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block; 不再需要target，而是传入一个block，在block里面进行循环调用方法 关于block怎么解决循环引用请看下面 block 简介block和其他语言的闭包或lambda表达式是一回事,block的使用很像函数指针，不过与函数最大的不同是：block可以访问函数以外、词法作用域以内的外部变量的值。换句话说，block不仅实现函数的功能，还能携带函数的执行环境。 block基本语法 123456789// 声明一个block变量long (^sum) (int, int) = nil;// sum是个block变量，该block类型有两个int型参数，返回类型是long。// 定义block并赋给变量sumsum = ^ long (int a, int b) &#123; return a + b;&#125;;// 调用block：long s = sum(1, 2); 定义一个实例函数，该函数返回block： 12345678- (long (^)(int, int)) sumBlock &#123; int base = 100; return [[ ^ long (int a, int b) &#123; return base + a + b; &#125; copy] autorelease]; &#125;// 调用block[self sumBlock](1,2); 根据在内存中的位置将block分为三种类型： * `NSGlobalBlock`: 类似函数，位于text段； * `NSStackBlock`: 位于栈内存，函数返回后block将无效； * `NSMallocBlock`: 位于堆内存。 block其实包含两个部分内容： block执行的代码，这是在编译的时候已经生成好的； 一个包含block执行时需要的所有外部变量值的数据结构。 block将使用到的、作用域附近到的变量的值建立一份快照拷贝到栈上。 block的数据结构 对于 block 外的变量引用，block 默认是将其复制到其数据结构中来实现访问的： 传入外部变量 对于用 __block 修饰的外部变量引用，block 是复制其引用地址来实现访问的： 用__block修饰 初步了解了block后看看它怎么构成循环引用并怎么解决的吧 12345678910111213typedef void(^block)();@property (copy, nonatomic) block myBlock;@property (copy, nonatomic) NSString *blockString;- (void)testBlock &#123; self.myBlock = ^() &#123; //其实注释中的代码，同样会造成循环引用 NSString *localString = self.blockString; //NSString *localString = _blockString; //[self doSomething]; &#125;;&#125; 看了前面关于block的一些介绍应该容易看出来，当我们往block中传入数据时是保存在了block的堆中，如上述代码中引用了self相当于对self进行了一次retain，而self本身持有block于是造成了循环引用，同时在block中release``self没有用，因为在block中操作作用范围仅仅来block的函数栈，影响不到堆中的self，解决方法如下： 12345__weak typeof(self) weakSelf = self;self.myBlock = ^()&#123; __strong typeof(weakSelf) = strongSelf; NSString *localString = strongSelf;&#125; 其中传入一个若引用就不会造成循环引用，然后在block的函数栈中用一个强指针来接受传进来的弱指针，防止弱指针被提前释放产生野指针。 参考文章：Cooper – 正确使用Block避免Cycle Retain和Crash唐巧 – 谈Objective-C block的实现Dev Talking – Objective-C中的Block delegate我们对代理的写法一般都是：1@property (nonatomic, weak) id&lt;TestDelegate&gt; delegate; 如果使用strong的话很明显会造成循环引用（delegate调用self的一些东西），今天被面试官问道如果使用delegate出现了循环引用怎么解决，我说用weak，他说换一个，然后就懵住了，只回答了思路，找到互相引用的对象(可以用Instruments)然后断开引用。 Autorelease 简介很好理解，字面意思上看就是自动释放，我们可以通过使用autorelease让编译器帮我们在某个时刻自动释放内存。在MRC时我们使用NSAutorelease类来使用自动释放机制，代码如下： 123NSAutoreleasePool pool = [[NSAutoreleasePool alloc] init];// Code benefitting from a local autorelease pool.[pool release]; 也可以直接使用[obj autorelease]。现在基本上都是ARC环境，这个时候我们使用的是autoreleasepool（自动释放池），比如常见的： 12345678910111213//iOS programint main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125;//Command line programint main(int argc, const char *argv[]) &#123; @autoreleasepool &#123; //... &#125; return 0;&#125; 它的作用是把我们在{}中申请的对象在事件处理完时自动释放掉，其中的原理推荐阅读Qi Tang的iOS 中的 Autorelease Pool。前面说到的事件处理完时其实就是一次runloop结束时。 runloop和autorelease 程序运行 -&gt; 开启事件循环 -&gt; 发生触摸事件 -&gt; 创建自动释放池 -&gt; 处理触摸事件 -&gt; 事件对象加入自动释放池 -&gt; 一次事件循环结束, 销毁自动释放池 什么时候用@autoreleasepool 写基于命令行的的程序时，就是没有UI框架，如AppKit等Cocoa框架时。 写循环，循环里面包含了大量临时创建的对象。（本文的例子） 创建了新的线程。（非Cocoa程序创建线程时才需要） 长时间在后台运行的任务。 利用@autoreleasepool优化循环当我们一个循环内创建了很多临时对象时，可以通过使用@autoreleasepool在每次循环结束时释放内存： 12345678910//来自Apple文档，见参考NSArray *urls = &lt;# An array of file URLs #&gt;;for (NSURL *url in urls) &#123; @autoreleasepool &#123; NSError *error; NSString *fileContents = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; /* Process the string, creating and autoreleasing more objects. */ &#125;&#125; 参考文章：sunnyxx —— 黑幕背后的AutoreleaseJerry4me —— iOS中autorelease的那些事儿tutuge —— @autoreleasepool-内存的分配与释放 修饰词","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://codingdoge.cn/tags/Swift/"},{"name":"OC","slug":"OC","permalink":"http://codingdoge.cn/tags/OC/"}]},{"title":"漫谈iOS系列之：多线程","slug":"title: 漫谈iOS系列之：多线程","date":"2017-07-17T03:17:00.000Z","updated":"2018-01-13T05:08:06.362Z","comments":true,"path":"2017/07/17/title: 漫谈iOS系列之：多线程/","link":"","permalink":"http://codingdoge.cn/2017/07/17/title: 漫谈iOS系列之：多线程/","excerpt":"","text":"线程基本概念线程（thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。线程的状态： 新生态（New Thread） 可运行态（Runnable） 阻塞/非运行态（Not Runnable） 死亡态（Dead） 死锁：是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。 死锁条件： 互斥条件：所谓互斥就是进程在某一时间内独占资源。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 创建线程的开销多线程的代价及上下文切换 pThreadPOSIX线程（POSIX Threads，常被缩写为Pthreads）是POSIX的线程标准，跨平台，适用于多种操作系统（类Unix操作系统中，都使用Pthreads作为操作系统的线程，Windows操作系统也有其移植版pthreads-win32），可移植性强，是一套纯C语言的通用API，且线程的生命周期需要程序员自己管理，使用难度较大，所以在实际开发中通常不使用。Pthreads API中大致共有100个函数调用，全都以”pthread_”开头，并可以分为四类： 线程管理，例如创建线程，等待(join)线程，查询线程状态等。 互斥锁（Mutex）：创建、摧毁、锁定、解锁、设置属性等操作。 条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作。 使用了互斥锁的线程间的同步管理。 pThread在实际开发中基本不使用，所以大概了解下就好了。 NSThreadGCDdispatch_barrier_async&amp;dispatch_barrier_sync在队列中，barrier块必须单独执行，不能与其他block并行。这只对并发队列有意义，并发队列如果发现接下来要执行的block是个barrier block，那么就一直要等到当前所有并发的block都执行完毕，才会单独执行这个barrier block代码块，等到这个barrier block执行完毕，再继续正常处理其他并发block。 async, sync两者区别在于async将自己的任务插入队列后, 不用等待自己的任务结束, 继续把后面的任务插入队列, 然后等待自己的任务运行结束才执行后面的任务, sync将自己的任务插入队列后，需要等待自己的任务运行结束才能将后面的任务插入队列。 12345678910111213141516171819202122232425262728293031323334353637#import &lt;Foundation/Foundation.h&gt; @interface Person : NSObject@property (nonatomic, copy) NSString *name;@end #import \"Person.h\" @interface Person ()@end static NSString *_name;static dispatch_queue_t _concurrentQueue;@implementation Person- (instancetype)init&#123; if (self = [super init]) &#123; _concurrentQueue = dispatch_queue_create(\"com.person.syncQueue\", DISPATCH_QUEUE_CONCURRENT); &#125; return self;&#125;- (void)setName:(NSString *)name&#123; dispatch_barrier_async(_concurrentQueue, ^&#123; _name = [name copy]; &#125;);&#125;- (NSString *)name&#123; __block NSString *tempName; dispatch_sync(_concurrentQueue, ^&#123; tempName = _name; &#125;); return tempName;&#125;@end NSOperationNSOperation默认是非并发的，当你调用-[NSOperation start]方法时，该方法会等任务结束才会返回；并发的NSOperation是指,当你调用-[NSOperation start]后，NSOperation会在非当前线程(建立一个NSThread，或是dispatch async等)执行任务，并在任务结束之前就返回; 需要注意的是，并发行为都需要你自己实现，若要实现并发，你需要做很多额外的工作： 你需要创建一个subclass； 除了重载main方法，实现并发你还需要至少重载；start,isConcurrent,isExecuting,isFinished四个方法； 在start里，创建Thread或者调用一个异步函数； 更新isExecuting，并且发送相应KVO消息； 任务结束后，你还得更新isExecuting和isFinished，发送相应KVO消息。实现一个并发的NSOperation比较少见，具体如何实现，可以读读文档: NSOperation Class Reference 大多数情况下NSOperation都设计成非并发，这样实现起来会简单很多;并且，一般会配合NSOperationQueue使用，由NSOperationQueue来负责执行NSOperation，而非直接调用-[NSOperation start]。 若有复杂任务需要并发执行，一般也是拆成多个NSOperation，由NSOperationQueue来并发的执行多个NSOperation。 参考:关于iOS多线程，你看我就够了 dispatch_barrier_sync和dispatch_barrier_asynciOS开发：深入理解GCD 第二篇（dispatch_group、dispatch_barrier、基于线程安全的多读单写）NSOperation的并发和非并发有什么区别呀？","categories":[{"name":"iOS","slug":"iOS","permalink":"http://codingdoge.cn/categories/iOS/"}],"tags":[{"name":"OC","slug":"OC","permalink":"http://codingdoge.cn/tags/OC/"}]},{"title":"剑指Offer —— 复杂链表的复制","slug":"title: 剑指Offer —— 复杂链表的复制","date":"2017-07-06T02:44:00.000Z","updated":"2018-01-14T17:25:14.000Z","comments":true,"path":"2017/07/06/title: 剑指Offer —— 复杂链表的复制/","link":"","permalink":"http://codingdoge.cn/2017/07/06/title: 剑指Offer —— 复杂链表的复制/","excerpt":"","text":"题目来源牛客网：复杂链表的复制 题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 数据结构123456789101112131415/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; &#125;&#125;; 解题思路一、递归思想：把大问题转化若干子问题此题转化为一个头结点和除去头结点剩余部分，剩余部分操作和原问题一致 123456789101112131415RandomListNode* Clone(RandomListNode* pHead) &#123; if(pHead==NULL) return NULL; //开辟一个新节点 RandomListNode* pClonedHead=new RandomListNode(pHead-&gt;label); pClonedHead-&gt;next = pHead-&gt;next; pClonedHead-&gt;random = pHead-&gt;random; //递归其他节点 pClonedHead-&gt;next=Clone(pHead-&gt;next); return pClonedHead; &#125; 二、 复制每个节点，如：复制节点A得到A1，将A1插入节点A后面 遍历链表，A1-&gt;random = A-&gt;random-&gt;next; 将链表拆分成原链表和复制后的链表 1234567891011121314151617181920212223242526272829RandomListNode* Clone(RandomListNode* pHead)&#123; if(!pHead) return NULL; RandomListNode *currNode = pHead; while(currNode)&#123; RandomListNode *node = new RandomListNode(currNode-&gt;label); node-&gt;next = currNode-&gt;next; currNode-&gt;next = node; currNode = node-&gt;next; &#125; currNode = pHead; while(currNode)&#123; RandomListNode *node = currNode-&gt;next; if(currNode-&gt;random)&#123; node-&gt;random = currNode-&gt;random-&gt;next; &#125; currNode = node-&gt;next; &#125; //拆分 RandomListNode *pCloneHead = pHead-&gt;next; RandomListNode *tmp; currNode = pHead; while(currNode-&gt;next)&#123; tmp = currNode-&gt;next; currNode-&gt;next =tmp-&gt;next; currNode = tmp; &#125; return pCloneHead; &#125; 三、哈希表法时间空间复杂度都是O(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061RandomListNode* Clone(RandomListNode* pHead)&#123; if(pHead==NULL) return NULL; //定义一个哈希表 unordered_multimap&lt;RandomListNode*,RandomListNode*&gt; table; // 开辟一个头结点 RandomListNode* pClonedHead=new RandomListNode(pHead-&gt;label); pClonedHead-&gt;next=NULL; pClonedHead-&gt;random=NULL; // 将头结点放入map中 table.insert(make_pair(pHead,pClonedHead)); //设置操作指针 RandomListNode* pNode=pHead-&gt;next; RandomListNode* pClonedNode=pClonedHead; // 第一遍先将简单链表复制一下 while(pNode!=NULL) &#123; // 不断开辟pNode的拷贝结点 RandomListNode* pClonedTail=new RandomListNode(pNode-&gt;label); pClonedTail-&gt;next=NULL; pClonedTail-&gt;random=NULL; //连接新节点，更新当前节点 pClonedNode-&gt;next=pClonedTail; pClonedNode=pClonedTail; //将对应关系 插入到哈希表中 table.insert(make_pair(pNode,pClonedTail)); //向后移动操作节点 pNode=pNode-&gt;next; &#125; //需从头开始设置random节点，设置操作指针 pNode=pHead; pClonedNode=pClonedHead; // 根据map中保存的数据，找到对应的节点 while(pNode!=NULL) &#123; if(pNode-&gt;random!=NULL) &#123; //找到对应节点，更新复制链表 pClonedNode-&gt;random=table.find(pNode-&gt;random)-&gt;second; &#125; //向后移动操作节点 pNode=pNode-&gt;next; pClonedNode=pClonedNode-&gt;next; &#125; return pClonedHead; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"http://codingdoge.cn/tags/剑指Offer/"}]},{"title":"动态规划（Dynamic Programming）","slug":"title: 动态规划（Dynamic Programming）","date":"2017-05-13T11:39:00.000Z","updated":"2018-01-12T14:27:10.181Z","comments":true,"path":"2017/05/13/title: 动态规划（Dynamic Programming）/","link":"","permalink":"http://codingdoge.cn/2017/05/13/title: 动态规划（Dynamic Programming）/","excerpt":"","text":"（以下简称DP） 基本思想将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。适合用DP求解的问题，经分解得到的子问题一般不是相互独立的，如果使用分治法求解，有些子问题会被重复计算多次，可以用一个表来记录所有已解决的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。 DP算法适用于解最优化问题。通常可以按以下步骤设计： 找出最优解的性质，并刻画其结构特征； 递归地定义最优值； 以自底向上的方式计算出最优值； 根据计算最优值时得到的信息，构造最优解 基本要素 最优子结构问题的最优解包含了其子问题的最优解。 重叠子问题在用递归算法自顶向下求解问题时，每次产生的子问题并不总是新问题，有些子问题被计算多次。DP算法正式利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，当再次需要解此问题时，只是简单地用常数时间查看一下结果。通常不同的子问题个数随问题的大小呈多项式增长，因此用DP算法通常只需要多项式时间，从而获得较高的解题效率。 最长公共子序列问题描述一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切的说，若给定序列X = {x1, x2, ..., xm}，则另一序列Z = {z1, z2, ..., zk}，X的子序列是指存在一个严格递增下标序列{i1, i2, ..., ik}使得对于所有j = 1, 2, ..., k有zj = xij。例如，序列Z = {B, C, D, B}是序列X = {A, B, C, B, D, A, B}的子序列，相应的递增下标序列为{2, 3, 5, 7}。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X = {A, B, C, B, D, A, B}，Y = {B, D, C, A, B, A}，序列{B, C, A}是X和Y的一个公共子序列，但它不是X和Y的最长公共子序列。序列{B, C, B, A}也是X和Y的一个公共子序列，它的长度为4，而且它是X和Y的最长公共子序列，因为X和Y没有长度大于4的公共子序列。 最长公共子序列问题给定两个序列X = {x1, x2, ..., xm}和Y = {y1, y2, ..., ym}，找出X和Y的最长公共子序列。 按照DP算法设计的各个步骤求解 最长公共子序列结构设序列X = {x1, x2, ..., xm}和Y = {y1, y2, ..., yn}的最长公共子序列为Z = {z1, z2, ..., zk}，则 若xm = yn，则zk = xm = yn，且Z 子问题的递归结构 计算最优值 构造最长公共子序列 算法的改进","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://codingdoge.cn/categories/Algorithm/"}],"tags":[]}]}