<!DOCTYPE html>
<html>
<head>
    

    

    
<!-- Baidu Tongji -->
<script>var _hmt = _hmt || []</script>
<script async src="//hm.baidu.com/hm.js?31bd755dfddd5e5e49c9007df8c7eb87"></script>
<!-- End Baidu Tongji -->




    <meta charset="utf-8">
    
    
    
    <title>常见排序算法总结 | CodingDoge | 关于开发、设计，关于生活。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="排序算法一般分为：  内部排序(In-place sort) 不占用额外内存或者占用常数内存，如：插入排序、选择排序、冒泡排序、堆排序、快速排序。 外部排序(Out-place sort) 因为排序数据大，可用内存一次不能容纳所有排序记录，排序过程中需要访问外存，如：归并排序、计数排序、基数排序、桶排序。  也分为：  稳定的排序(stable sort) 插入排序、冒泡排序、归并排序、计数排序、">
<meta property="og:type" content="article">
<meta property="og:title" content="常见排序算法总结">
<meta property="og:url" content="http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /index.html">
<meta property="og:site_name" content="CodingDoge">
<meta property="og:description" content="排序算法一般分为：  内部排序(In-place sort) 不占用额外内存或者占用常数内存，如：插入排序、选择排序、冒泡排序、堆排序、快速排序。 外部排序(Out-place sort) 因为排序数据大，可用内存一次不能容纳所有排序记录，排序过程中需要访问外存，如：归并排序、计数排序、基数排序、桶排序。  也分为：  稳定的排序(stable sort) 插入排序、冒泡排序、归并排序、计数排序、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918530488431.gif?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918534447677.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918802730993.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918816323841.gif?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918818530845.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918826895959.gif?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918830727069.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918847712647.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918848199034.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918856456281.jpg?imageView2/0/q/100)。从根到叶的筛选，元素比较次数至多2(k-1">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918856037036.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918857702506.gif?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918858207359.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918867109600.gif?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918869209728.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918869418896.jpg?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918886605315.gif?imageView2/0/q/100">
<meta property="og:image" content="http://oo8snaf4x.bkt.clouddn.com/14918924354057.jpg?imageView2/0/q/100">
<meta property="og:updated_time" content="2018-01-14T16:45:17.006Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常见排序算法总结">
<meta name="twitter:description" content="排序算法一般分为：  内部排序(In-place sort) 不占用额外内存或者占用常数内存，如：插入排序、选择排序、冒泡排序、堆排序、快速排序。 外部排序(Out-place sort) 因为排序数据大，可用内存一次不能容纳所有排序记录，排序过程中需要访问外存，如：归并排序、计数排序、基数排序、桶排序。  也分为：  稳定的排序(stable sort) 插入排序、冒泡排序、归并排序、计数排序、">
<meta name="twitter:image" content="http://oo8snaf4x.bkt.clouddn.com/14918530488431.gif?imageView2/0/q/100">
    
        <link rel="alternate" type="application/atom+xml" title="CodingDoge" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">CodingDoge</h5>
          <a href="mailto:dogecoding@outlook.com" title="dogecoding@outlook.com" class="mail">dogecoding@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/DogeCoding" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://weibo.com/u/1766673540" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                Weibo
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-link"></i>
                About
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">常见排序算法总结</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">常见排序算法总结</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-07-23T15:56:00.000Z" itemprop="datePublished" class="page-time">
  2017-07-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Algorithm/">Algorithm</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#插入排序"><span class="post-toc-number">1.</span> <span class="post-toc-text">插入排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-直接插入排序（Straight-Insertion-Sort）"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">1.直接插入排序（Straight Insertion Sort）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-希尔排序（Shell’s-Sort）"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">2.希尔排序（Shell’s Sort）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#选择排序"><span class="post-toc-number">2.</span> <span class="post-toc-text">选择排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简单选择排序（Simple-Selection-Sort）"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">简单选择排序（Simple Selection Sort）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#简单排序的改进——二元选择排序"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">简单排序的改进——二元选择排序</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#堆排序（Heap-Sort）"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">堆排序（Heap Sort）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#交换排序"><span class="post-toc-number">3.</span> <span class="post-toc-text">交换排序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#冒泡排序（Bubble-Sort）"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">冒泡排序（Bubble Sort）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#冒泡算法的改进"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">冒泡算法的改进</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#快速排序（Quick-Sort）"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">快速排序（Quick Sort）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#归并排序（Merge-Sort）"><span class="post-toc-number">4.</span> <span class="post-toc-text">归并排序（Merge Sort）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#递归法"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">递归法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#两路归并的递归算法"><span class="post-toc-number">4.1.1.</span> <span class="post-toc-text">两路归并的递归算法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#迭代法"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">迭代法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-number">5.</span> <span class="post-toc-text">总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#各种排序的稳定性，时间复杂度和空间复杂度总结："><span class="post-toc-number">5.1.</span> <span class="post-toc-text">各种排序的稳定性，时间复杂度和空间复杂度总结：</span></a></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-title: 常见排序算法总结  "
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">常见排序算法总结</h1>
        <div class="post-meta">
            <time class="post-time" title="2017-07-23 23:56:00" datetime="2017-07-23T15:56:00.000Z"  itemprop="datePublished">2017-07-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Algorithm/">Algorithm</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>排序算法一般分为：</p>
<ol>
<li>内部排序(In-place sort)<br> 不占用额外内存或者占用常数内存，如：插入排序、选择排序、冒泡排序、堆排序、快速排序。</li>
<li>外部排序(Out-place sort)<br> 因为排序数据大，可用内存一次不能容纳所有排序记录，排序过程中需要访问外存，如：归并排序、计数排序、基数排序、桶排序。</li>
</ol>
<p>也分为：</p>
<ol>
<li>稳定的排序(stable sort)<br> 插入排序、冒泡排序、归并排序、计数排序、基数排序、桶排序。</li>
<li>不稳定的排序(unstable sort)<br> 选择排序、快速排序、堆排序。<blockquote>
<p>算法的稳定性：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，ri=rj，且ri在rj之前，而在排序后的序列中，ri仍在rj之前，则称这种排序算法是稳定的；否则称为不稳定的。  </p>
<hr>
<p>不稳定算法的改进：只需要在每个输入元素加一个index，表示初始时的数组索引，当不稳定的算法排好序后，对于相同的元素对index排序即可。</p>
</blockquote>
</li>
</ol>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918530488431.gif?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>最优复杂度：当输入数组就是排好序的时候，复杂度为O(n)，而快速排序在这种情况下会产生O(n^2)的复杂度。<br>最差复杂度：当输入数组为倒序时，复杂度为O(n^2)。</p>
<blockquote>
<p>插入排序比较适合用于“少量元素的数组”。插入排序比较适合用于“少量元素的数组”。</p>
</blockquote>
<h3 id="1-直接插入排序（Straight-Insertion-Sort）"><a href="#1-直接插入排序（Straight-Insertion-Sort）" class="headerlink" title="1.直接插入排序（Straight Insertion Sort）"></a>1.直接插入排序（Straight Insertion Sort）</h3><hr>
<p>工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<p>直接插入排序示例：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918534447677.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<blockquote>
<p>如果排序时碰到相等的元素，比较后会把相等的元素放在后面，所以这两个相等的元素之间的前后顺序没有改变，排序是稳定的。</p>
</blockquote>
<p>算法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(a[i] &lt; a[i<span class="number">-1</span>])   <span class="comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> j = i<span class="number">-1</span>;</div><div class="line">            <span class="keyword">int</span> temp = a[i];    <span class="comment">//存储待排序元素</span></div><div class="line">            a[i] = a[i<span class="number">-1</span>];      <span class="comment">//先后移一个元素</span></div><div class="line">            <span class="keyword">while</span>(x &lt; a[j] &amp;&amp; j &gt;= <span class="number">0</span>)     <span class="comment">//查找在有序表中的插入位置，并注意边界判断</span></div><div class="line">            &#123;</div><div class="line">                a[j+<span class="number">1</span>] = a[j];</div><div class="line">                j--;         <span class="comment">//元素后移</span></div><div class="line">            &#125;</div><div class="line">            a[j+<span class="number">1</span>] = temp;      <span class="comment">//插入到正确位置</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。直接插入排序算法的优化算法有：二分插入排序，2-路插入排序。</p>
</blockquote>
<h3 id="2-希尔排序（Shell’s-Sort）"><a href="#2-希尔排序（Shell’s-Sort）" class="headerlink" title="2.希尔排序（Shell’s Sort）"></a>2.希尔排序（Shell’s Sort）</h3><hr>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。它是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>基本原理是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。算法具体描述如下：</p>
<ol>
<li>选择一个步长，其设计者Donald Shell最初建议步长选择为<strong>n/2</strong>并且对步长取半直到步长达到1；</li>
<li>以步长为间隔对序列进行排序；</li>
<li>重复步骤2直到步长为1。</li>
</ol>
<p>希尔排序的示例：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918802730993.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<blockquote>
<p>希尔排序是不稳定的。</p>
</blockquote>
<p>算法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap=n&gt;&gt;<span class="number">1</span>; gap&gt;<span class="number">0</span>; gap&gt;&gt;=<span class="number">1</span>) <span class="comment">// 确定步长，直到步长为1</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=gap; i&lt;n; i++) <span class="comment">// 以步长为间隔进行排序</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> temp = a[i];</div><div class="line">            <span class="keyword">int</span> j;</div><div class="line">            <span class="keyword">for</span> (j=i-gap; j&gt;=<span class="number">0</span>&amp;&amp;a[j]&gt;temp; j-=gap)   <span class="comment">// 排序细节</span></div><div class="line">            a[j+gap] = a[j];</div><div class="line">            a[j+gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自两个算式<a href="http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments" target="_blank" rel="noopener">[1]</a>。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918816323841.gif?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="简单选择排序（Simple-Selection-Sort）"><a href="#简单选择排序（Simple-Selection-Sort）" class="headerlink" title="简单选择排序（Simple Selection Sort）"></a>简单选择排序（Simple Selection Sort）</h3><hr>
<p>基本原理是在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。算法的具体描述如下：</p>
<ol>
<li>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</li>
<li><p>第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；</p>
</li>
<li><p>以此类推…..</p>
</li>
<li><p>第i趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，</p>
</li>
</ol>
<p>直到整个序列按关键码有序。</p>
<p>简单选择排序的示例：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918818530845.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>算法实现：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SelectSort(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</div><div class="line">&#123;</div><div class="line">true<span class="keyword">int</span> <span class="built_in">min</span> = a[<span class="number">0</span>];</div><div class="line">true<span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">true&#123;</div><div class="line">truetrue<span class="built_in">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++)	<span class="comment">// 每次选出序列中最小的数</span></div><div class="line">truetruetrue<span class="built_in">if</span> (a[j] &lt; <span class="built_in">min</span>)</div><div class="line">truetruetruetrue<span class="built_in">min</span> = a[j];</div><div class="line">truetruea[i] = <span class="built_in">min</span>;	<span class="comment">// 将每次选好的数放在正确的位置</span></div><div class="line">true&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>选择排序是稳定的。</p>
</blockquote>
<p>选择排序的交换操作介于<strong>0</strong>和<strong>(n-1)</strong>次之间。选择排序的比较操作为<strong>n(n-1)</strong>次之间。选择排序的赋值操作介于<strong>0</strong>和<strong>3(n-1)</strong>次之间。<br>比较次数<strong>O(n^2 )</strong>，比较次数与关键字的初始状态无关，总的比较次数<strong>N=(n-1)+(n-2)+…+1=n(n-1)/2</strong>。交换次数<strong>O(n)</strong>，最好情况是，已经有序，交换<strong>0</strong>次；最坏情况是，逆序，交换<strong>n-1</strong>次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，<strong>n</strong>值较小时，选择排序比冒泡排序快。<br>原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p>
<h4 id="简单排序的改进——二元选择排序"><a href="#简单排序的改进——二元选择排序" class="headerlink" title="简单排序的改进——二元选择排序"></a>简单排序的改进——二元选择排序</h4><p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。具体实现如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SelectSort(<span class="keyword">int</span> r[],<span class="keyword">int</span> n) &#123;  </div><div class="line">    <span class="keyword">int</span> i ,j , <span class="built_in">min</span> ,<span class="built_in">max</span>, tmp;  </div><div class="line">    <span class="built_in">for</span> (i=<span class="number">1</span> ;i &lt;= n/<span class="number">2</span>;i++) &#123;    </div><div class="line">        <span class="comment">// 做不超过n/2趟选择排序   </span></div><div class="line">        <span class="built_in">min</span> = i; <span class="built_in">max</span> = i ; <span class="comment">//分别记录最大和最小关键字记录位置  </span></div><div class="line">        <span class="built_in">for</span> (j= i+<span class="number">1</span>; j&lt;= n-i; j++) &#123;  </div><div class="line">            <span class="built_in">if</span> (r[j] &gt; r[<span class="built_in">max</span>]) &#123;   </div><div class="line">                <span class="built_in">max</span> = j ; <span class="built_in">continue</span> ;   </div><div class="line">            &#125;    </div><div class="line">            <span class="built_in">if</span> (r[j]&lt; r[<span class="built_in">min</span>]) &#123;   </div><div class="line">                <span class="built_in">min</span> = j ;   </div><div class="line">            &#125;     </div><div class="line">      &#125;    </div><div class="line">      <span class="comment">//该交换操作还可分情况讨论以提高效率  </span></div><div class="line">      tmp = r[i<span class="number">-1</span>]; r[i<span class="number">-1</span>] = r[<span class="built_in">min</span>]; r[<span class="built_in">min</span>] = tmp;  </div><div class="line">      tmp = r[n-i]; r[n-i] = r[<span class="built_in">max</span>]; r[<span class="built_in">max</span>] = tmp;  </div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918826895959.gif?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。其基本原理如下：<br>堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。<br>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：</p>
<ol>
<li>大顶堆序列：（96, 83, 27, 38, 11, 09)</li>
<li>小顶堆序列：（12, 36, 24, 85, 47, 30, 53, 91）<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918830727069.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>  
</li>
</ol>
<p>初始时把n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），调整它们的存储序，使之成为一个堆，将堆顶元素输出，得到n个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。<br>因此，实现堆排序需解决两个问题：</p>
<ol>
<li>如何将n 个待排序的数建成堆；</li>
<li>输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</li>
</ol>
<p>首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。调整小顶堆的方法：</p>
<ol>
<li>设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</li>
<li>将根结点与左、右子树中较小元素的进行交换。</li>
<li>若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 2.</li>
<li>若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 2.</li>
<li>继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。</li>
</ol>
<p>称这个自根结点到叶子结点的调整过程为筛选。如图：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918847712647.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>再讨论对n 个元素初始建堆的过程。<br>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。</p>
<ol>
<li>n个结点的完全二叉树，则最后一个结点是第个结点的子树。</li>
<li>筛选从第个结点为根的子树开始，该子树成为堆。</li>
<li>之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</li>
</ol>
<p>如图建堆初始过程：无序序列：（49，38，65，97，76，13，27，49）<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918848199034.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>算法的实现：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line"> * 已知H[s…m]除了H[s] 外均满足堆的定义 </div><div class="line"> * 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,  </div><div class="line"> * </div><div class="line"> * @param H是待调整的堆数组 </div><div class="line"> * @param s是待调整的数组元素的位置 </div><div class="line"> * @param length是数组的长度 </div><div class="line"> * </div><div class="line"> */  </div><div class="line"><span class="type">void</span> HeapAdjust(<span class="type">int</span> H[],<span class="type">int</span> s, <span class="type">int</span> <span class="built_in">length</span>)  </div><div class="line">&#123;  </div><div class="line">    <span class="type">int</span> tmp  = H[s];  </div><div class="line">    <span class="type">int</span> child = <span class="number">2</span>*s+<span class="number">1</span>; <span class="comment">//左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)  </span></div><div class="line">    <span class="keyword">while</span> (child &lt; <span class="built_in">length</span>)</div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(child+<span class="number">1</span> &lt;<span class="built_in">length</span> &amp;&amp; H[child]&lt;H[child+<span class="number">1</span>])  <span class="comment">// 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)  </span></div><div class="line">            ++child;  </div><div class="line">        <span class="keyword">if</span>(H[s]&lt;H[child])</div><div class="line">        &#123;  <span class="comment">// 如果较大的子结点大于父结点  </span></div><div class="line">            H[s] = H[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点  </span></div><div class="line">            s = child;       <span class="comment">// 重新设置s ,即待调整的下一个结点的位置  </span></div><div class="line">            child = <span class="number">2</span>*s+<span class="number">1</span>;  </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>            <span class="comment">// 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出  </span></div><div class="line">             <span class="keyword">break</span>;   </div><div class="line">        H[s] = tmp;         <span class="comment">// 当前待调整的结点放到比其大的孩子结点位置上  </span></div><div class="line">    &#125;   </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"> * 初始堆进行调整 </div><div class="line"> * 将H[0..length-1]建成堆 </div><div class="line"> * 调整完之后第一个元素是序列的最小的元素 </div><div class="line"> */  </div><div class="line"><span class="type">void</span> BuildingHeap(<span class="type">int</span> H[], <span class="type">int</span> <span class="built_in">length</span>)  </div><div class="line">&#123;   </div><div class="line">    <span class="comment">//最后一个有孩子的节点的位置 i=  (length -1) / 2  </span></div><div class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="built_in">length</span> <span class="number">-1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; i--)  </div><div class="line">        HeapAdjust(H,i,<span class="built_in">length</span>);</div><div class="line">&#125;  </div><div class="line"><span class="comment">/** </span></div><div class="line"> * 堆排序算法 </div><div class="line"> */  </div><div class="line"><span class="type">void</span> HeapSort(<span class="type">int</span> H[],<span class="type">int</span> <span class="built_in">length</span>)  </div><div class="line">&#123;  </div><div class="line">    <span class="comment">//初始堆  </span></div><div class="line">    BuildingHeap(H, <span class="built_in">length</span>);  </div><div class="line">    <span class="comment">//从最后一个元素开始对序列进行调整  </span></div><div class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">length</span> - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//交换堆顶元素H[0]和堆中最后一个元素  </span></div><div class="line">        <span class="type">int</span> temp = H[i]; H[i] = H[<span class="number">0</span>]; H[<span class="number">0</span>] = temp;  </div><div class="line">        <span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整  </span></div><div class="line">        HeapAdjust(H,<span class="number">0</span>,i);  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>堆排序是不稳定的。</p>
</blockquote>
<p>设树深度为k，<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918856456281.jpg?imageView2/0/q/100)。从根到叶的筛选，元素比较次数至多2(k-1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918856037036.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn )。</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918857702506.gif?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>冒泡排序示例：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918858207359.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure><br>算法的实现：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void <span class="keyword">bubbleSort(int </span>a[], int n)</div><div class="line">&#123;  </div><div class="line">    for(int i =<span class="number">0</span> <span class="comment">; i&lt; n-1; ++i)</span></div><div class="line">        for(int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt; n-i-1; ++j) </span></div><div class="line">            if(a[<span class="keyword">j] </span>&gt; a[<span class="keyword">j+1]) </span> </div><div class="line">            &#123;  </div><div class="line">                int tmp = a[<span class="keyword">j];</span></div><div class="line">                a[<span class="keyword">j] </span>= a[<span class="keyword">j+1];</span></div><div class="line">                a[<span class="keyword">j+1] </span>= tmp<span class="comment">;  </span></div><div class="line">            &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>冒泡排序是稳定的。</p>
</blockquote>
<h4 id="冒泡算法的改进"><a href="#冒泡算法的改进" class="headerlink" title="冒泡算法的改进"></a>冒泡算法的改进</h4><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：</p>
<ol>
<li>设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>改进后算法如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_1</span> <span class="params">( <span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span></span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i = n <span class="number">-1</span>;  <span class="comment">//初始时,最后位置保持不变  </span></div><div class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>)</div><div class="line">    &#123;   </div><div class="line">        <span class="keyword">int</span> pos= <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换  </span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)  </div><div class="line">            <span class="keyword">if</span> (r[j] &gt; r[j+<span class="number">1</span>])</div><div class="line">            &#123;  </div><div class="line">                pos = j; <span class="comment">//记录交换的位置   </span></div><div class="line">                <span class="keyword">int</span> tmp = r[j];</div><div class="line">                r[j] = r[j+<span class="number">1</span>];</div><div class="line">                r[j+<span class="number">1</span>] = tmp;  </div><div class="line">            &#125;   </div><div class="line">        i = pos; <span class="comment">//为下一趟排序作准备  </span></div><div class="line">     &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。<br>改进后的算法为：</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void <span class="keyword">Bubble_2 </span>(int r[], int n)</div><div class="line">&#123;  </div><div class="line">    int low = <span class="number">0</span><span class="comment">;   </span></div><div class="line">    int high = n-1<span class="comment">; //设置变量的初始值  </span></div><div class="line">    int tmp, <span class="keyword">j; </span> </div><div class="line">    while (low &lt; high)</div><div class="line">    &#123;  </div><div class="line">        for (<span class="keyword">j </span>= low<span class="comment">; j &lt; high; ++j) //正向冒泡,找到最大者  </span></div><div class="line">            if (r[<span class="keyword">j] </span>&gt; r[<span class="keyword">j+1])</span></div><div class="line">            &#123;  </div><div class="line">                tmp = r[<span class="keyword">j];</span></div><div class="line">                r[<span class="keyword">j]=r[j+1];</span></div><div class="line">                r[<span class="keyword">j+1]=tmp; </span> </div><div class="line">            &#125;   </div><div class="line">        --high<span class="comment">;                 //修改high值, 前移一位  </span></div><div class="line">        for (<span class="keyword">j </span>= high<span class="comment">; j &gt; low; --j) //反向冒泡,找到最小者  </span></div><div class="line">            if (r[<span class="keyword">j] </span>&lt; r[<span class="keyword">j-1])</span></div><div class="line">            &#123;  </div><div class="line">                tmp = r[<span class="keyword">j];</span></div><div class="line">                r[<span class="keyword">j]=r[j-1];</span></div><div class="line">                r[<span class="keyword">j-1]=tmp; </span> </div><div class="line">            &#125;  </div><div class="line">        ++low<span class="comment">;                  //修改low值,后移一位  </span></div><div class="line">    &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918867109600.gif?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>快速排序又称划分交换排序（partition-exchange sort），使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。其算法描述为：</p>
<ol>
<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>快速排序的示例：</p>
<ol>
<li><p>一趟排序的过程</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918869209728.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
<li><p>排序的全过程</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918869418896.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ol>
<p>算法的实现（递归）：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void quickSort_recursive(int a[], int low, int high)</div><div class="line">&#123;</div><div class="line">    int <span class="built_in">first</span> = low;</div><div class="line">    int <span class="built_in">last</span> = high;</div><div class="line">    int <span class="built_in">key</span> = a[<span class="built_in">first</span>];</div><div class="line">    <span class="keyword">if</span>(low &gt;= high)</div><div class="line">        <span class="built_in">return</span> ;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">first</span> &lt; <span class="built_in">last</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">while</span>((<span class="built_in">first</span> &lt; <span class="built_in">last</span>)&amp;&amp;(<span class="built_in">key</span> &lt;= a[<span class="built_in">last</span>]))</div><div class="line">            <span class="built_in">last</span>--;</div><div class="line">        a[<span class="built_in">first</span>] = a[<span class="built_in">last</span>];</div><div class="line">        <span class="keyword">while</span>((<span class="built_in">first</span> &lt; <span class="built_in">last</span>)&amp;&amp;(<span class="built_in">key</span> &gt;= a[<span class="built_in">first</span>]))</div><div class="line">            <span class="built_in">first</span>++;</div><div class="line">        a[<span class="built_in">last</span>] = a[<span class="built_in">first</span>];</div><div class="line">    &#125;</div><div class="line">    a[<span class="built_in">first</span>] = <span class="built_in">key</span>;</div><div class="line">    quickSort_recursive(a, low, <span class="built_in">first</span>-<span class="number">1</span>);</div><div class="line">    quickSort_recursive(a, <span class="built_in">first</span>+<span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>快速排序是不稳定的。<br>快排迭代算法:维护一个栈，存放划分的起点终点</p>
</blockquote>
<p>在平均状况下，排序n个项目要Ο(nlogn)次比较。在最坏状况下（正序或逆序）则需要Ο(n^2 )次比较，取决于其递归树的高度。事实上，快速排序通常明显比其他Ο(nlogn)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。快速排序是一个不稳定的排序方法。</p>
<h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><hr>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918886605315.gif?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><ol>
<li>将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素</li>
<li>将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素</li>
<li>重复步骤2，直到所有元素排序完毕</li>
</ol>
<p>算法实现：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> merge_sort_recursive(<span class="keyword">int</span> arr[], <span class="keyword">int</span> <span class="keyword">reg</span>[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="keyword">end</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (start &gt;= <span class="keyword">end</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> len = <span class="keyword">end</span> - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</div><div class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</div><div class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = <span class="keyword">end</span>;</div><div class="line">    merge_sort_recursive(arr, <span class="keyword">reg</span>, start1, end1);</div><div class="line">    merge_sort_recursive(arr, <span class="keyword">reg</span>, start2, end2);</div><div class="line">    <span class="keyword">int</span> k = start;</div><div class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</div><div class="line">        <span class="keyword">reg</span>[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</div><div class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</div><div class="line">        <span class="keyword">reg</span>[k++] = arr[start1++];</div><div class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</div><div class="line">        <span class="keyword">reg</span>[k++] = arr[start2++];</div><div class="line">    <span class="keyword">for</span> (k = start; k &lt;= <span class="keyword">end</span>; k++)</div><div class="line">        arr[k] = <span class="keyword">reg</span>[k];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> merge_sort(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</div><div class="line">&#123;</div><div class="line">true<span class="keyword">int</span> <span class="keyword">reg</span>[len];</div><div class="line">truemerge_sort_recursive(arr, <span class="keyword">reg</span>, <span class="number">0</span>, len - <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="两路归并的递归算法"><a href="#两路归并的递归算法" class="headerlink" title="两路归并的递归算法"></a>两路归并的递归算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(ElemType *r, ElemType *rf,<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span>  </span></div><div class="line">&#123;   </div><div class="line">    ElemType *rf2;  </div><div class="line">    <span class="keyword">if</span>(s==t) r[s] = rf[s];  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">    &#123;   </div><div class="line">        <span class="keyword">int</span> m=(s+t)/<span class="number">2</span>;          <span class="comment">/*平分*p 表*/</span>  </div><div class="line">        MSort(r, rf2, s, m);        <span class="comment">/*递归地将p[s…m]归并为有序的p2[s…m]*/</span>  </div><div class="line">        MSort(r, rf2, m+<span class="number">1</span>, t);      <span class="comment">/*递归地将p[m+1…t]归并为有序的p2[m+1…t]*/</span>  </div><div class="line">        Merge(rf2, rf, s, m+<span class="number">1</span>,t);   <span class="comment">/*将p2[s…m]和p2[m+1…t]归并到p1[s…t]*/</span>  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort_recursive</span><span class="params">(ElemType *r, ElemType *rf, <span class="keyword">int</span> n)</span>  </span></div><div class="line">&#123;   <span class="comment">/*对顺序表*p 作归并排序*/</span>  </div><div class="line">    MSort(r, rf,<span class="number">0</span>, n<span class="number">-1</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤3直到某一指针到达序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾；</li>
</ol>
<p>算法实现：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void merge_sort_iteration(<span class="built_in">int</span> arr[], <span class="built_in">int</span> <span class="built_in">len</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span>* a = arr;</div><div class="line">    <span class="built_in">int</span>* b = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">len</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> seg = <span class="number">1</span>; seg &lt; <span class="built_in">len</span>; seg += seg)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> start = <span class="number">0</span>; start &lt; <span class="built_in">len</span>; start += seg + seg)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">int</span> low = start, <span class="built_in">mid</span> = min(start + seg, <span class="built_in">len</span>), high = min(start + seg + seg, <span class="built_in">len</span>);</div><div class="line">            <span class="built_in">int</span> k = low;</div><div class="line">            <span class="built_in">int</span> start1 = low, end1 = <span class="built_in">mid</span>;</div><div class="line">            <span class="built_in">int</span> start2 = <span class="built_in">mid</span>, end2 = high;</div><div class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</div><div class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</div><div class="line">            <span class="keyword">while</span> (start1 &lt; end1)</div><div class="line">                b[k++] = a[start1++];</div><div class="line">            <span class="keyword">while</span> (start2 &lt; end2)</div><div class="line">                b[k++] = a[start2++];</div><div class="line">        &#125;</div><div class="line">        T* temp = a;</div><div class="line">        a = b;</div><div class="line">        b = temp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (a != arr)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++)</div><div class="line">            b[i] = a[i];</div><div class="line">        b = a;</div><div class="line">    &#125;</div><div class="line">    delete[] b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>归并排序是稳定的。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="各种排序的稳定性，时间复杂度和空间复杂度总结："><a href="#各种排序的稳定性，时间复杂度和空间复杂度总结：" class="headerlink" title="各种排序的稳定性，时间复杂度和空间复杂度总结："></a>各种排序的稳定性，时间复杂度和空间复杂度总结：</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oo8snaf4x.bkt.clouddn.com/14918924354057.jpg?imageView2/0/q/100" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<blockquote>
<p>参考资料有：<br>真实的归宿——<a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a><br>xiazdong——<a href="http://blog.csdn.net/xiazdong/article/details/8462393" target="_blank" rel="noopener">九大排序算法再总结</a><br><a href="https://zh.wikipedia.org/wiki/Wikipedia:首页" target="_blank" rel="noopener">wikipedia</a></p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-01-14T16:45:17.006Z" itemprop="dateUpdated">2018-01-15 00:45:17</time>
</span><br>


        
        <a href="/2017/07/23/title: 常见排序算法总结  /" target="_blank" rel="external">http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /</a>
        
    </div>
    <footer>
        <a href="http://codingdoge.cn">
            <img src="/img/avatar.jpg" alt="CodingDoge">
            CodingDoge
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /&title=《常见排序算法总结》 — CodingDoge&pic=http://codingdoge.cn/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /&title=《常见排序算法总结》 — CodingDoge&source=Keep it simple, stuip." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《常见排序算法总结》 — CodingDoge&url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /&via=http://codingdoge.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/07/23/title: Remove Duplicates from Sorted Array  /" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Remove Duplicates from Sorted Array</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/07/23/title: self与super的区别 /" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">self与super的区别</h4>
      </a>
    </div>
  
</nav>



    














</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>CodingDoge &copy; 2016 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /&title=《常见排序算法总结》 — CodingDoge&pic=http://codingdoge.cn/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /&title=《常见排序算法总结》 — CodingDoge&source=Keep it simple, stuip." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《常见排序算法总结》 — CodingDoge&url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /&via=http://codingdoge.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://codingdoge.cn/2017/07/23/title: 常见排序算法总结  /" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtUlEQVR42u3aQW7jQAwEQP//01kgV6/lZlMTJ0DpFBiCpJrDDNPk4xFfX99Xfufz/a9+eb6u73mcuPDw8PCqT79+WfL7MyOnXi9Q8j0vlwAPDw/vGO/6MEjw16TppyfLGh1geHh4eB/l5dt6vqHnJTseHh7e3+V1SzAogvHw8PD+CK8rmpMCeh/j5t+Ah4eH9zO8zab8qb8P9vfw8PDwFl31vKk/fdp+64/egoeHh3eAt2ky5WMByQIlxXc37IWHh4d3L2+/Eed1bLIE+TJF0QkeHh7eMV4ewibxbt5ay4vs7jvx8PDwTvDyAjd/QRIEJ6FG9N9A/AQ8PDy8e3ldA747JPKhhA42aIPh4eHhVbxNwTotiPP13hTiUesLDw8Pb8FLGlQbWD5q0D1hPHqFh4eHdxMvGX7Km1X567vYtxt3wMPDw7uXt9nEN4dBEklMy/HBKuLh4eHdVHPmm3409jRcxM1bBv09PDw8vAVviukWIh8ySNpmSYyLh4eHd46XN5a6gKAb3uoaXYOhKzw8PLwFb1qwdk396UBAPgT25n48PDy8w7xp6bwJdqetsvy9eHh4eJ/i5Vt818TKw4ibp8nw8PDw1ryuxTXFd4MCG9h/shY8PDy8W3mbuKH7ZYrfh7x4eHh49/KmYe40fu22+24QAQ8PD+80r3t9txzdkTBdAjw8PLyf5HXXXW2tzSBXFEDg4eHh3cTrDoMuup0CpgHum/vx8PDwbuLtj4HNsNR0MGtciOPh4eEd4J0ofJOANR9ByAvoEoaHh4dX8fLDYFN255/eFetvZsrw8PDwDvA2zfs8eO0WYnNo4eHh4X2Wl0cDSeiQF995zPGypMbDw8P7lbwufs0B0wMJDw8P7zQvDyM2we50dGAzjoCHh4d3jjdtgE2bXt2RsyqjN/09PDw8vCvePwQRp6y5w2PlAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '呀你走了吗';
            clearTimeout(titleTime);
        } else {
            document.title = '你回来啦';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
