
title: Objective-C声明在头文件和实现文件中的区别  
tags: iOS
---

> 转自[codecloud](http://codecloud.net/objective-c-6782.html)(有整理)  

### 调试程序的时候，突然想到这个问题，百度一下发现有不少这方面的问答，粗略总结一下:  
* 属性写在.h文件中和在.m文件中有什么区别?  

Objective-C中有分类和类扩展的概念，而实现文件中的类声明实际上就是类扩展.  
> @interface部分为类扩展（extension  

其被设计出来就是为了解决两个问题的  

1. 定义类私有方法的地方，也就是下面说到的区别一  
2. 实现public readonly,private readwrite的property（意思是在h头文件中定义一个属性对外是readonly的，但在类的内部希望是可读写的，所以可以在m源文件中的@interface部分重新定义此属性为readwrite，此时此属性对外是只读的，对内是读写的）.  

此外，也可在此部分申明变量和属性，但申明的变量，属性和方法均为私有的，只能够被当前类访问，相当于private。  

####区别一：

属性在.h文件中和在.m中声明是有区别的。区别就是，在.h文件中声明的属性，外部类可以通过“类实例.属性”来调用，但在.m中声明的则不可以，获取和设置的方法，只能是通过setValue:forKey和valueForKey来实现。 
 
成员变量，有三种权限，就是大家都知道的@private、@protected、@public ，写在.m文件中时，相当于是@private权限，子类无法访问，验证了一下，做权限修改也无效。而写在.h文件中，默认是@protected权限，子类可以访问，可以做权限修改。因为访问权限指针对.h文件。.h文件中成员变量，外部类对其的调用，跟C++一样，用->来调用。  

####区别二  

这样可以提高编译效率，避免重复编译。
因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大提高了效率。这样可以提高编译效率，避免重复编译.  

>怎么去解释呢...其实这是一个面向对象的思想，所谓"提高"的比较对象，应该是直接将方法写到具体函数里的实现方式.  
h为编译器提供一个索引、声明，连接obj对象和主程序.  
编译器在编译的时候，如果需要，则去查找h，找到了h，再找对应的obj，就可以找到类的方法了.  
但是如果直接写入到同一个文件（例如hpp），主程序没有索引，也不清楚具体的类实现了没有，只能一次次重复的编译相同的代码，这样实际上没有把这个类该有的东西抽象出来.  
对于函数声明在头文件中，在实现文件中实现，也是避免重复编译，函数可以多次声明，但只能实现一次.  

###头文件相对于实现文件的作用在于:  

1. 头文件可以预先告诉编译器一些必要的声明,让编译器顺利进行下去,在连接实现以前.未必出现实际的定义.  

		头文件的意义在:  
		* 使得程序简明,清晰.
		* 避免了重复编写相同的声明代码.  
2. **.c和**.h文件没有必然的联系.

###关于头文件和实现文件的编译连接的过程  
其实要理解C文件与头文件有什么不同之处，首先需要弄明白编译器的工作过程，一般说来编译器会做以下几个过程:  

1. 预处理阶段  
2. 词法与语法分析阶段  
3. 编译阶段，首先编译成纯汇编语句，再将之汇编成跟CPU相关的二进制码，生成各个目标文件  
4. 连接阶段，将各个目标文件中的各段代码进行绝对地址定位，生成跟特定平台相关的可执行文件，当然，最后还可以用objcopy生成纯二进制
码，也就是去掉了文件格式信息.

编译器在编译时是以C文件为单位进行的，也就是说如果你的项目中一个C文件都没有，那么你的项目将无法编译，连接器是以目标文件为单位
，它将一个或多个目标文件进行函数与变量的重定位，生成最终的可执行文件，在PC上的程序开发，一般都有一个main函数，这是各个编译器
的约定，当然，你如果自己写连接器脚本的话，可以不用main函数作为程序入口！！！！

有了这些基础知识，再言归正传，为了生成一个最终的可执行文件，就需要一些目标文件，也就是需要C文件，而这些C文件中又需要一个main
函数作为可执行程序的入口，那么我们就从一个C文件入手，假定这个C文件内容如下：
<pre><code>#include \<stdio.h>
\#include “mytest.h”

int main(int argc,char **argv)
{
test = 25;
printf(“test……………..%d\n”,test);
}</code></pre>

头文件内容如下:  
<code>int test;</code>

####现在以这个例子来讲解编译器的工作:  
1. 预处理阶段:  
编译器以C文件作为一个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会将相应头文件中再去处理宏，变量，函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件中，形成一个中间“C文件”  

2. 编译阶段:  
在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件  

3. 连接阶段:  
将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件，主要的工作就是重定位各个目标文件的函数，变量等，相当于将个目标文件中的二进制码按一定的规范合到一个文件中  

###再回到C文件与头文件各写什么内容的话题上：
理论上来说C文件与头文件里的内容，只要是C语言所支持的，无论写什么都可以的，比如你在头文件中写函数体，只要在任何一个C文件包含此头文件就可以将这个函数编译成目标文件的一部分（编译是以C文件为单位的，如果不在任何C文件中包含此头文件的话，这段代码就形同虚设），你可以在C文件中进行函数声明，变量声明，结构体声明，这也不成问题！！！  
那为何一定要分成头文件与C文件呢？又为何一般都在头件中进行函数，变量声明，宏声明，结构体声明呢？而在C文件中去进行变量定义，函数实现呢？？  
原因如下:  

1. 如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错  

2. 如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间  

3. 如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一下头文件就行了  

4. 在头文件中声明结构体，函数等，当你需要将你的代码封装成一个库，让别人来用你的代码，你又不想公布源码，那么人家如何利用你的库呢？也就是如何利用你的库中的各个函数呢？？一种方法是公布源码，别人想怎么用就怎么用，另一种是提供头文件，别人从头文件中看你的函数原型，这样人家才知道如何调用你写的函数，就如同你调用printf函数一样，里面的参数是怎样的？？你是怎么知道的？？还不是看人家  
的头文件中的相关声明啊！！！当然这些东东都成了C标准，就算不看人家的头文件，你一样可以知道怎么使用.

